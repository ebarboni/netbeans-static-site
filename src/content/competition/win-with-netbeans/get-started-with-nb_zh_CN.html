<html>
	<head>
	  <META NAME="AUDIENCE" CONTENT="NBUSER">
	  <META NAME="TYPE" CONTENT="ARTICLE">
	  <META NAME="TOPIC" CONTENT="BASIC">
	  <META NAME="description" CONTENT="Getting Started with NetBeans and Java">
	  <link rel="stylesheet" type="text/css" href="../../netbeans.css">
		<title>NetBeans 和 Java 入门指南</title>
		</head>
	<body>

		<h1>NetBeans 和 Java 入门指南</h1>
<div class="articledate" style="margin-left:0px;">撰稿人：Ben Suter，<a href="../../competition/win-with-netbeans.html">与 NetBeans 共赢</a>参赛作品</div></p>
		<p>本文假定您成功安装了 NetBeans 4.0 和 Java SDK（也称为 JDK）。
		<!-- If you have not yet done so, please refer to <a href="https://netbeans.org/kb/articles/nb-install-sequence.html">this brief introduction</a>, which shows the step-by-step installation sequence for NetBeans.</p> -->

		<p>我们先介绍新的 IDE 以及一个嵌入的样例应用程序。第一部分使用了大量的屏幕快照，以使您在安装完 NetBeans 后立即开始使用。然后，我们将了解如何使用 NetBeans 修改、编译和运行简单的 Java 应用程序。随着介绍的深入，我们将减少使用的屏幕快照并增加使用的源代码。在我们学习使用一些更高级的 NetBeans 增效功能时，我们将加快步伐，同时在 &quot;Anagram Game&quot; 样例应用程序中添加一些有趣的增强功能。在阅读完本文后，您将了解如何使用 NetBeans 编写 Java 代码以打开和分析 XML 文档，通过简单的对话框请求用户输入，等等。最重要的是，您在朝着自己创建和扩展 Java 应用程序方向迈出了坚实的一步。让我们开始吧！</p>


		<ol>
			<li><a href="#1">准备工作：了解 NetBeans 和启动项目</a></li>
			<li><a href="#2">修改源代码</a></li>
			<li><a href="#3">为什么如此好预测？</a></li>
			<li><a href="#4">java.util.Random 的一剂良药</a></li>
			<li><a href="#5">从文件中装入单词列表</a></li>
			<li><a href="#files">相关文件列表</a></li>
		</ol>

		<h2><a name="1">准备工作：了解 NetBeans 和启动项目</a></h2>

		<p>当我第一次从 &quot;Start&quot;（开始）菜单中启动 NetBeans 时，大约 15 秒就能完成装入。在某些情况下，第一次可能需要更长的时间，因为 NetBeans 需要了解您的系统。 </p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-initial-splash.png" />
		<p>此时，您可以随意四处看看 - 如果有疑问，请选择 &quot;Cancel&quot;（取消）！当您准备好时，请单击 &quot;Welcome&quot;（欢迎）图形下面的 &quot;Sample Project&quot;（样例项目）按钮。</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-1-choose.png" />
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-2.png" />
		<p>缺省情况下，项目位置将设置为 home 文件夹。然后，让我们在 C: 驱动器中创建一个名为 &quot;code&quot; 的文件夹，然后在其中创建一个名为 &quot;Java&quot; 的文件夹。接下来，使用 &quot;Browse&quot;（浏览）按钮选择新文件夹作为项目位置，如下一屏幕快照中所示。</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-3.png" />
		<p>在上面的对话框中单击 &quot;Finish&quot;（完成）后，将显示 &quot;Scanning Project Classpaths&quot;（扫描项目类路径）对话框，可能会持续一分钟左右的时间。</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-4-scanningclasspath.png" />
		<p>现在，左“窗格”中的 &quot;Projects&quot;（项目）标签显示一个标题为 &quot;AnagramGame&quot; 的节点。在“主”区域中仍然可以看见欢迎闪屏。如果展开 &quot;Projects&quot;（项目）标签中的 &quot;AnagramGame&quot; 节点并依次展开它的所有子节点，则会显示以下树结构：</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-projectstructure.png" />
		<p>我已经通过如上操作调整了主 NetBeans 窗口大小以仅显示左“窗格”。</p>
		<p>值得注意的是，该样例应用程序包含两个“源包”（一个用于库，另一个用于用户界面）和一个“测试包”（用于库）。还要注意，每个类除了具有字段/构造函数/方法以外，还具有一个 &quot;Bean Patterns&quot;（Bean 模式）节点（但对于上面的每个当前类，该节点是空的）。在本文中，我们不使用 &quot;Bean Patterns&quot;（Bean 模式）节点，但您应该知道这些节点通过使用 <a href="http://java.sun.com/products/javabeans/index.jsp">JavaBeans 组件</a>来帮助提高代码模块性、灵活性和重用性。</p>
		<p>接下来，我们双击 &quot;About.java&quot; 节点 - 将会看到类似下面的内容：</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-about-designmode.png" />
		<p>如果您愿意，您现在可以关闭主区域/窗格中的 &quot;Welcome&quot;（欢迎）标签。此时，您可能再次希望自己了解 NetBeans 功能：您可以打开源文件，查看某些用户界面类的可视化“表单”，或者从 &quot;Projects&quot;（项目）切换到左窗格的 &quot;Files&quot;（文件）标签以检查非源文件。您可以在其中查看各种 .properties 文件和 Ant 生成脚本。通过 &quot;Tools&quot;（工具）菜单打开 &quot;Options&quot;（选项）窗口，您可以在其中了解该 IDE 实际上是多么灵活和可高度定制！</p>
		<p>此外，为了确保您在中断后知道如何重新开始，让我们关闭 NetBeans，然后将其重新打开。如果您这样做，则会发现此时打开的 IDE 包含空白的主区域，并且 &quot;Projets&quot;（项目）区域显示 AnagramGame 项目。现在，单击工具栏中的 &quot;Run Main Project (F6)&quot;（运行主项目 (F6)）按钮（它是黄绿色的；您可以将鼠标悬停在该按钮上以查看图标的标题），NetBeans 将打开 &quot;Output&quot;（输出）窗口，其中包含以下文本：</p>
<pre class='examplecode'>
init:
deps-jar:
Created dir: C:\code\java\AnagramGame\build\classes
Compiling 3 source files to C:\code\java\AnagramGame\build\classes
compile:
run:
</pre>
		<p>此外，还会弹出一个小窗口，即，AnagramGame 的用户界面。</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-game-1.png" />
		<p>我第一次猜，就猜对了！我认为浏览查看以前的所有项目文件夹和文件会很有帮助，因为我记得看到过一个很长的单词列表（我假定是打乱顺序的单词列表），这会帮我理顺单词的顺序。让我们先把这想法放在心里，到后面再说...</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-game-2.png" />


		<h2><a name="2">修改源代码</a></h2>

		<p>首先，我们仅在样例应用程序中更改一条用户消息的文本。在 &quot;Projects&quot;（项目）窗格中，双击 com.toy.anagrams.ui.Anagrams 节点，其源代码将在主窗口区域中作为新标签打开。该标签的左上角具有 &quot;Design&quot;（设计）和 &quot;Source&quot;（源）按钮。选择 &quot;Source&quot;（源）按钮（如果尚未选择）- 您现在应该会在编辑器中看到 Anagrams 类的 Java 源代码。右键单击左旁注并确保选中 &quot;Show Line Numbers&quot;（显示行号）。转到第 211 行（快捷方式是 Ctrl-G）。该行的内容为：</p>
		<pre class='examplecode'>feedbackLabel.setText(&quot;Incorrect! Try again!&quot;);</pre>
		<p>我们将对文本进行小小的修改，编译并运行应用程序，错误地猜测单词，将会看到修改的消息。我修改后的内容为：</p>
		<pre class='examplecode'>feedbackLabel.setText(&quot;Not quite ... please try again!&quot;);</pre>
		<p>此时，请注意编辑器标签标题中的文字 &quot;Anagrams&quot; 和 &quot;X&quot;（关闭命令）之间现在有一个小星号。该星号用于指示该文件已修改，但没有保存。&quot;File&quot;（文件）-&gt; &quot;Save&quot;（保存）（或 Ctrl-S）将保存所做的更改。此时，已修改并保存我们的源文件，但编译的类文件仍然反映的是旧代码。NetBeans 在此处同时处理两个步骤：单击绿色/黄色的 &quot;Run Main Project&quot;（运行主项目）图标，或直接按 F6 键。将像前面一样打开应用程序。不过，在输出控制台中，您应该会看到以下内容：</p>
<pre class='examplecode'>
init:
deps-jar:
Compiling 1 source file to C:\code\java\AnagramGame\build\classes
compile:
run:
</pre>
		<p>正如您可能看到的一样，在运行应用程序之前，NetBeans（实际是 Ant 生成脚本）意识到文件已修改，并在执行“运行任务”之前编译该文件。输入猜测的单词，最好是不正确的单词。如果一切按预期方式进行，现在显示的反馈消息应包含上面定制的文本。</p>
		<p>再试两次 - 我被 &quot;iccrmutsnaec&quot; 难住了。为了进一步说明 NetBeans 的基本功能，我作了点弊，即，搜索源代码以查找正确结果。这预先假定项目的某个源文件中列出了每个单词的打乱顺序版本，而不是在每次随机打乱原始单词顺序时生成的。我们马上就会看到这实际是当前实现的性质决定的，稍后我们将对该实现进行一些处理...</p>
		<p>在 &quot;Projects&quot;（项目）标签中，右键单击 &quot;Source Packages&quot;（源包)节点，然后从上下文菜单中选择 &quot;Find ...&quot;（查找...）。将显示下面名为 &quot;Find&quot;（查找）的屏幕：</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-find-1.png" />
		<p>在此屏幕快照中，您可以看到我已输入 &quot;iccrmutsnaec&quot; 文本作为搜索词。我们将所有其他设置保留不变，然后单击 &quot;Search&quot;（搜索）以开始搜索过程。输出控制台旁边将显示一个新标签以指示搜索结果。正如您可能看到的一样，在 &quot;WordLibrary.java&quot; 文件的第 53 行中找到一个匹配项：</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-find-2.png" />
		<p>双击该匹配项（上面标有 &quot;iccrmutsnaec&quot; 的节点，[位置 63:10]）。这会在编辑器中打开相应的源文件，确保相应的行位于视图中，然后突出显示匹配的短语。您应该会看到，&quot;iccrmutsnaec&quot; 一词是字符串数组中的第 6 项，该数组的名称为 &quot;SCRAMBLED_WORD_LIST&quot;。现在，我们可以观察到另一个字符串数组位于该数组的正上方，但条目似乎为实际英语单词。让我们看一下数组的名称是什么：&quot;WORD_LIST&quot;。此时，我肯定我们已找到了打乱顺序的单词 &quot;iccrmutsnaec&quot; 的正确结果，它是 &quot;WORD_LIST&quot; 数组的第 6 项。当然啦，原始单词作者可能会选择在明文单词和打乱顺序版本之间提供不太明显的映射，但幸运的是他们没有这么做！查看第 16 行，我们将看到 &quot;circumstance&quot; 单词。在应用程序中键入此单词时（如果在此期间关闭了应用程序，您可以在适当的时候重试），我们将看到以下屏幕：</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-game-3.png" />


		<h2><a name="3">为什么如此好预测？</a></h2>

		<p>现在，我们知道了如何打开文件以进行编辑，修改源代码，编译并运行应用程序，搜索源代码以及如何作弊。让我们将其中的一些技巧结合在一起，以使 AnagramGame 变得更有趣。我们将实现动态生成打乱顺序的单词的方法，从而不需要在源代码中维护打乱顺序的单词列表。因此，这也使我们无法再以这种方法作弊。在第二个步骤中，我们将确保打乱顺序的版本是随机生成的，以使游戏玩起来更有趣。</p>
		<p>仍然在 WordLibrary 源代码中，您将会看到一个名为 &quot;getScrambledWord&quot; 的方法。通过更仔细地分析该方法，我们看到其实现是非常简单的：</p>
		<pre class='examplecode'>return SCRAMBLED_WORD_LIST[idx];</pre>
		<p>这的确是一个进行修改的好地方。让我们先将该行（第 126 行）更改为以下内容：</p>
		<pre class='examplecode'>return generateScrambledWord(idx);</pre>

		<p>NetBeans 现在使用红色波浪下划线标记该代码行，并在旁注中显示红色 X 图标以表明在源代码中发现语法问题。如果将光标放在带有下划线的源代码的任何部分上，则会显示一条小消息，指出无法识别方法签名 generateScrambledWord(int)。当然啦，我们尚未创建该方法，因此，让我们立即创建该方法吧。我们只需将其添加到类末尾，从第 147 行开始：</p>
<pre class='examplecode'>
    /**
     * For a specified index, finds the corresponding word in the
     * dictionary and generates a scrambled version of this word.
     * @param idx index of the word to be scrambled
     * @return a scrambled version of the relevant word
     */
    protected static String generateScrambledWord(int idx)
    {
	int j = 0;
	String word;
	String scrambled = &quot;&quot;;
	java.util.Random r;

	r = new java.util.Random();
	word = getWord(idx);

	for (j = 0; j &lt;word.length(); j++)
	{
	    if ( r.nextBoolean() )
		scrambled = scrambled + word.charAt(j);
	    else
		scrambled = word.charAt(j) + scrambled;
	}

	return scrambled;
    }
</pre>
		<p>generateScrambledWord(int) 函数的用途是，返回由整数参数 index 指定的字典条目的打乱顺序版本。我肯定我们可以想出一些不同的方法来打乱单词的字母顺序（重新排序），您可以按您认为合适的方法任意实现该方法的主体。这可能就像颠倒字母顺序一样简单，但游戏可能太容易玩而变得索然无味了（请试一试）。或者，我们也可以交换任何两个相邻字母的位置，每次交换一对字母，直至到达单词末尾。请发挥您的想象力，找出一种既可轻松实现又能使游戏变得非常有趣的算法。让我简要说明一下我在此示例中提供的实现的基本思路。我选择以某种方式使用 Java 内置随机数生成实用程序，以使每次为给定单词生成的打乱顺序结果都不相同。我们构造打乱顺序的单词，每次一个字母；对于每个新字母，我们让随机数确定是将新字母添加到单词片段的开头还是结尾。这样，我们构造的新单词包含原始单词的所有字母，但具有新的随机顺序。此时，让我们运行应用程序。这一次，我无法正确猜出很多单词，但由于排序的随机性，您有时可能会看到未打乱顺序的单词与打乱顺序的形式非常接近。您可以尝试的一种方法是，修改上述算法以重新对字符对进行排序，而不是对单个字符重新排序而导致单词很容易认出来。如果实现的算法使游戏特别好玩，记得与本文的所有读者一起分享呀！</p>
		<p>此时，我们不再使用打乱顺序的字典（SCRAMBLED_WORD_LIST 数组），因此，让我们将其从 WordLibary.java 源代码（57-104 行）中删除。</p>


		<h2><a name="4">java.util.Random 的一剂良药</a></h2>

		<p>如果玩新版本的游戏，您可能会（像我一样）由于猜不出原始单词而一筹莫展。那怎么办呢？我们知道原始单词存储在一个简单的字典中，我们还知道游戏从开头到结尾遍历该字典，每次一个单词。对于当前的代码，由于我们可以访问源代码，因此，我们仍然可以通过跟踪已尝试了多少个单词以及查找相应的字典条目来作弊。在运行游戏时，我看到的第一个打乱顺序的单词是 noiatabsrct，我没有立即认出来该单词。但是，如果我转到 WordLibrary.java 中的第 11 行，就会看到第一个字典条目是 abstraction。我们的下一个目标是，随机指定从字典中提取单词的顺序，我们将再次使用 java.util 包的 Random 类来实现此目的。由于我们现在使用了两次该类，让我们快速查看一下它的 API 文档，以使我们对它的用途有一个基本的了解：</p>
		<p>该类实例用于生成一组伪随机数。该类使用一个 48 位的种子，这是使用线性同余公式修改的。（请参见 Donald Knuth 编写的 The Art of Computer Programming 第 2 卷中的第 3.2.1 节。）如果两个 Random 实例是使用相同种子创建的，并且对每个实例进行相同顺序的方法调用，它们将生成并返回相同顺序的数字。</p>
		<p>到目前为止，为了方便起见，我们使用了 java.util.Random 的零参数构造函数。正如上面的 API 注释所示，我们应使用唯一的种子初始化每个 Random 实例，否则，在重复使用应用程序时，可能没有足够高的随机性。通过查看零参数构造函数的<a href="http://java.sun.com/j2se/1.4.2/">文档</a>，我们会看到它实际使用当前时间（毫秒）作为种子，因此，我们的现有代码是合乎要求的，我们可以继续完成更重要的工作。</p>
		<p>我们需要进行哪些更改以随机指定从字典中选择单词的顺序？在 WordLibrary 类中，我们看到有两种方法似乎是相关的：getWord(int idx) 和 getScrambledWord(int idx) 均接受将字典索引作为其参数。首先，我们将光标放在 getWord 的方法名称上，然后右键单击并选择 &quot;Find Usages&quot;（查找使用实例）选项。我们看到此方法的三个调用（一个在 WordLibraryTest 中，另外两个在 WordLibrary 本身中）。这些调用由 WordLibrary 组件（包括其测试环境）在内部使用，我们不需要在其中更改任何内容。接下来，我们将光标放在 getScrambledWord 的方法名称上，然后按 Alt-F7 组合键。我们再次看到该方法的三个使用实例，但现在有两个使用实例位于 Anagrams 类中，让我们将重点放在这两个使用实例上。在这两处（第 28 行和第 195 行），为 getScrambledWord 传递的参数值是名为 wordIdx 的变量。该变量本身是在第 22 行声明的，并初始化为零。让我们搜索 wordIdx 变量的使用实例：共有三个使用实例。</p>
		<ol>
			<li>在第 28 行中，我们看到游戏的构造函数最初使用字典中的第一个单词填充打乱顺序的单词控件。</li>
			<li>在 nextTrialActionPerformed 方法中，wordIdx 变量顺次递增（请注意，如果尝试了所有单词，它将重复使用值 0），并使用新值填充打乱顺序的单词控件。</li>
			<li>在 guessedWordActionPerformed 方法中，使用当前 wordIdx 变量值评估用户的猜测内容以指示相关的单词。</li>
		</ol>
		<p>我们现在看到 wordIdx 变量决定了每次猜测后选择的单词，并且仅在一个地方修改了该变量，即 Anagrams.java 的第 192 行：</p>
		<pre class='examplecode'>wordIdx = (wordIdx + 1) % WordLibrary.getSize();</pre>
		<p>要随机指定从字典中选择单词的顺序，我们需要修改该行，以使 wordIdx 使用在字典的上下限范围内的随机值。这正是 java.util.Random.nextInt(int n) 方法执行的操作，因此，让我们将第 192 行替换为以下代码行：</p>
		<pre class='examplecode'>wordIdx = new java.util.Random().nextInt(WordLibrary.getSize());</pre>
		<p>要查看这是否获得了所需的效果，我们还得再玩一次游戏！现在，第一个单词很容易猜出来，它似乎始终是打乱顺序的 abstraction 单词形式。事实上，Anagram 构造函数始终在字典中选择第一个单词以启动游戏，因为 wordIdx 变量将静态初始化为值 0。但在猜出来游戏的第一个单词后，后面选择的所有单词就不太好预测了。因此，我们有希望使游戏变得更好玩一些，而我们几乎只剩下一种作弊方法了（假定您可以读取源代码的话）。如果您愿意，您可以确保游戏的第一个单词也是从字典中随机选择的。为此，只需确保 wordIdx 变量的初始值是按与后续值相同的方式计算的 - 为此，Anagrams.java 的第 22 行将变为：</p>
		<pre class='examplecode'>private int wordIdx = wordIdx = new java.util.Random().nextInt(WordLibrary.getSize());</pre>


		<h2><a name="5">从文件中装入单词列表</a></h2>

		<p>如果您和我一样，您可能会猜到 elxical 是打乱顺序的 lexical 形式，但在看到 lasiugsidintinhbe 时，您会立即将其当作是新词。一般来说，为什么 indistinguishable 会比 lexical 更难认出来呢？就当前打乱单词顺序的算法而言，原始单词中的字母越少，打乱顺序的单词形式与原始单词的差别就越小。更通俗地说，我发现单词越短，就越容易认出来打乱顺序的单词，而与打乱顺序的方法无关。因此，对于刚入门的玩家来说，一组较短的单词会比较有趣，而对于经验丰富的拼字游戏玩家，一组较长的单词可能会更适合。当然啦，除了单词长度以外，还有一些其他特性，例如，单词是很少使用，还是人们在讲话、语言或话题中经常用到。我们可以运用这些常识使游戏变得更有用，以及我们可以在玩游戏时学到有关 NetBeans 和 Java 的新知识吗？</p>
		<p>在本节中，我们将字典放在外部，这意味着，可以使用一些不同的单词列表来玩游戏，用户甚至可以提供自己的定制单词列表。当然啦，可以通过多种方法实现此目的；我们通过读取包含单词列表并将结构和格式设置为 XML 的文件来实现此功能。到本节结束时，您将了解如何从本地文件系统或 Web 中打开和读取文件并有效地分析简单的 XML 文件。</p>

		<p>我们希望添加一个新菜单项以装入外部单词列表。为此，我们切换到设计模式。原来显示的内容如下所示：</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-loadWordList.png" />
		<p>切换后变为：</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-designMode.png" />
		<p>在设计模式下，我们还会在右侧看到一个名为 &quot;Inspector&quot;（检查器）的面板。该面板最初如下所示：</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-form-inspector-initial.png" />
		<p>&quot;Inspector&quot;（检查器）面板向我们显示组成图形用户界面的 Swing 组件的分层结构。如果我们展开 [JFrame] 节点，将会看到第一个组件的名称为 mainMenu [JMenuBar]。而该组件又包含 fileMenu [JMenu] 项，该项本身包含两个其他节点：aboutMenuItem [JMenuItem] 和 exitMenuItem [JMenuItem]。我们在此处看到的模式是，每个节点标有相应变量的名称，并在后面的方括号中指定组件的类型。事实上，主框架就是 Anagrams 类本身（它是从 JFrame 继承的），因此，检查器不显示第一个组件的实例名称。我们的目标是添加一个菜单命令以装入外部单词列表，因此，让我们使用检查器在 &quot;File&quot; 菜单中的 &quot;About&quot; 和 &quot;Exit&quot; 条目之间添加一个新项。</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-form-inspector-addingMenuItem.png" />
		<p>右键单击 fileMenuItem 节点，选择 &quot;Add&quot;（添加），然后选择 &quot;JMenuItem&quot;。将添加一个新菜单项，它在 &quot;Exit&quot; 项目后面的第三个位置。最初，NetBeans 为此项提供一个自动生成的名称，但我们会将该名称更改为 openNewListMenuItem。方法是，右键单击新项，然后选择 &quot;Rename&quot;（重命名）。最后，我们再次右键单击新项并选择 &quot;Move Up&quot;（上移），这会按所需的顺序进行排列。</p>
		<p>现在，我们选择 exitMenuItem，然后在检查器正下方的 &quot;Properties&quot;（属性）面板中单击 &quot;Properties&quot;（属性）按钮。除了一些其他属性以外，我们还会看到下面三个有趣的属性：mnemonic、text、toolTipText。对于该特定菜单项，这些属性的值分别是 E、Exit 和 Quit Team, Quit!。让我们选择新菜单项，并将其相应属性分别设置为 O、Open Word List 和 Choose a new word list file 以替换当前的列表。</p>
		<p>接下来，我们希望添加在用户选择此菜单项时运行的代码。NetBeans 会再次帮我们添加代码，在检查器中，右键单击 openNewListMenuItem 节点，选择 &quot;Events&quot;（事件），选择 &quot;Action&quot;（操作），然后从展开菜单中选择 &quot;actionPerformed&quot;。NetBeans 将创建一个事件处理程序方法并返回到 &quot;Source&quot;（源）视图，以使我们可以开始编写所需的实现。将自动为新方法指定名称 openNewListMenuItemActionPerformed，但如果您愿意，您可以使用重构命令安全地将其重命名。顺便说一下，对于那些以前可能使用过 Swing GUI 设计器工具的人来说，看到自动生成的代码的结构、命名和格式设置如此井然有序，会给人一种耳目一新的感觉。例如，&quot;File&quot; 菜单中的三个项的代码与菜单项本身保持相同的顺序。返回到手头的工作：当用户选择 &quot;Open Word List&quot; 菜单项时，我们让他们在本地文件系统上选择一个文件，然后尝试打开、分析和使用新单词列表。如果该文件不可用，或者不包含有效的单词列表，游戏将继续使用当前的单词列表。下面是 NetBeans 为我们提供的初始内容：</p>
<pre class='examplecode'>
private void openNewListMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
// TODO add your handling code here:
}
</pre>
		<p>加载器将 URL 作为其主参数，因此，我们需要根据用户选择的文件生成相应的 URL。首先，我们创建一个 JFileChooser 实例，然后使用该实例显示 &quot;Open File&quot; 对话框。如果用户选择一个文件，我们通过预先在绝对路径名称中添加 file:/// 协议以便为其生成 URL。</p>
<pre class='examplecode'>
   private void openNewListMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
	/* The &quot;initialDirectory&quot; variable determines what directory is first displayed
	 * when choosing a new word list. An empty or a null string will start the chooser
	 * in the user's default directory, which for Windows is typically &quot;My Documents&quot;,
	 * and for *nix is typically the user's home directory.
	 */
	String initialDirectory = &quot;&quot;;
	String fileURL;
	JFileChooser chooser;
	int returnVal;

	chooser = new JFileChooser(initialDirectory);
	returnVal = chooser.showOpenDialog((Component) evt.getSource());

	if ( returnVal == chooser.APPROVE_OPTION )
	{
	    /* To create a URL for a file on the local file-system, we simply
	     * pre-pend the &quot;file&quot; protocol to the absolute path of the file.
	     */
	    fileURL = &quot;file:///&quot; + chooser.getSelectedFile().getAbsolutePath();
	    this.loadWordList(fileURL);
	}
    }
</pre>
		<p>上面的方法说明了如何为用户提供一个文件选择器对话框；然后，它调用目前未知的方法 loadWordList。该方法应将单词列表文件地址作为参数（假设该文件是完好的），并替换当前的单词列表。该方法如下所示：</p>
<pre class='examplecode'>
    /**
     * Attempts to open and parse an XML file containing a
     * word list. If successful, this list of words will be
     * used in place of the current list.
     * The URL can for example point to a document on the local file-system,
     * such as &quot;file:///C:/testlist.xml&quot;, or to a document on the World Wide Web,
     * such as &quot;http://www.stanford.edu/~bsuter/simplewordlist.xml&quot;.
     *
     * @param url Address of an XML document containing a word list.
     */
    protected void loadWordList(String url)
    {
	/* Create an instance of the loader */
	com.toy.anagrams.lib.WordListFileLoader wlfl = new com.toy.anagrams.lib.WordListFileLoader();

	/* Open and parse the file, replace the current word list with the newly loaded list. */
	WordLibrary.setWordList(wlfl.loadList(url));

	/* Since the new word list's number of entries may be different from the old,
	 * we make sure that the current value of wordIdx is valid for the new list.
	 */
	wordIdx = new java.util.Random().nextInt(WordLibrary.getSize());
    }
</pre>
		<p>我们看到游戏中有一个名为 WordListFileLoader 的新类。此外，WordLibrary 类还具有一个名为 setWordList 的新方法。我在第 125 行中添加了该方法，它是非常简单的：</p>
<pre class='examplecode'>
    public static void setWordList(String[] wordList)
    {
	if ( wordList != null )
	    WORD_LIST = wordList;
    }
</pre>
		<p><a href="https://netbeans.org/files/documents/4/307/WordListFileLoader.java">此处</a>提供了新 WordListFileLoader 类的完整源代码，但我们将逐条介绍重要的部分。新类具有一个重要方法以及一个从 org.xml.sax.helpers.DefaultHandler 继承的内部类。WordListFileLoader 实例用于打开、读取、分析和评估本地文件系统中的 XML 文件或可通过 HTTP 访问的 XML 文件的内容。让我们看一下 WordListFileLoader.loadList 方法执行的操作的简要说明：</p>
		<ul>
			<li>获取指定文档的 InputStream</li>
			<li>为该文档创建 SAX（用于 XML 的简单 API）分析器</li>
			<li>设置处理程序以响应来自 SAX 分析器的所有相关事件</li>
		</ul>
		<p>可以通过多种方法分析使用 Java 编写的 XML 文档。普遍采用的 DOM（文档对象模型）方法将生成内存中的 XML 文档节点集分层结构模型。此处，我们的数据集结构非常简单（一个单词列表），我们会立即将分析的列表转换为 String[] 数组，因此，将 XML 文档保留在内存中并没有什么意义。SAX 是一种基于事件的方法，处理程序类侦听在分析器遇到 XML 元素、属性或元素结尾时发生的分析器事件。处理程序可以选择处理或忽视任何此类事件。如果合乎要求，往往优先使用基于 SAX 的方法，因为它可以轻松处理非常大的文档。</p>
<pre class='examplecode'>
   public String[] loadList(String url)
   {
	InputStream is;
	try {
		URL u = new URL(url);
		is = u.openConnection().getInputStream();
	} catch (IOException ioe) {
	    report(&quot;Unable to open or find the specified wordlist.&quot;);
	    is = null;
	}

	if (is == null)
	{
	    report(&quot;Unable to load the requested wordlist. An error occurred while opening the file.&quot;);
	    return null;
	}

	SAXParserFactory parserFactory = SAXParserFactory.newInstance();
	SAXParser parser;
	try {
	  parser = parserFactory.newSAXParser();
	} catch ( ParserConfigurationException pce ) {
	    report(&quot;Error setting up the XML Parser. The parser is not properly configured. Loading aborted.&quot;);
	    return null;
	} catch ( SAXException saxe ) {
	    report(&quot;Error setting up the XML Parser. Loading aborted.&quot;);
	    return null;
	}

	try {
	    WordListHandler handler = new WordListHandler();
	    parser.parse(is, handler);
	} catch ( Exception e ) {
	    report(&quot;Unable to load the list, probably while performing SAX parsing.&quot;);
	    return null;
	}

	return this.list;
    }
</pre>
		<p>如上所述，SAX 处理程序必须实现不同的事件处理程序，此处恰好有三种事件：元素开头、元素内容以及元素结尾。结果代码如下所示：</p>
<pre class='examplecode'>
   public class WordListHandler extends DefaultHandler
   {
	protected String nodeType;
	protected ArrayList al;

	public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException
	{
	    if ( qName == &quot;word&quot; )
	    {
		nodeType = &quot;word&quot;;
	    } else if ( qName == &quot;wordlist&quot; ) {
	       al = new ArrayList();
	    }
	}

	public void endElement(String uri, String localName, String qName) throws SAXException
	{
	     if ( qName == &quot;word&quot; )
	     {
		 nodeType = null;
	     } else if (qName == &quot;wordlist&quot; ) {
		 /* Cast the ArrayList to a an array of String objects. */
		 list = (String[]) this.al.toArray(new String[al.size()]);
	     }
	}

	public void characters(char[] chars, int start, int length) throws SAXException
	{
	    if ( this.nodeType == &quot;word&quot; )
	    {
		this.al.add(new String(chars, start, length).trim());
	    }
	}
    }
</pre>
		<p>我们的单词列表文档结构仅包含两种类型的 XML 元素：&lt;word&gt; 和 &lt;wordlist&gt;。在此代码列表中，您可以看到在列表中添加新单词的实际工作是在 characters 方法中完成的。另外两种方法跟踪我们当前读取的节点，并执行相应的设置和清除操作，例如，相应地初始化新的单词列表和更新外部类列表字段。</p>
		<p><a href="https://netbeans.org/files/documents/4/307/WordListFileLoader.java">此处</a>提供了完整的 WordListFileLoader Java 源代码。<a href="https://netbeans.org/files/documents/4/305/simplelist.xml">此处</a>提供了样例单词列表文档，可能如下所示：</p>
<pre class='examplecode'>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;wordlist&gt;
    &lt;word&gt;welcome&lt;/word&gt;
    &lt;word&gt;jacuzzi&lt;/word&gt;
    &lt;word&gt;elefant&lt;/word&gt;
    &lt;word&gt;abracadabra&lt;/word&gt;
&lt;/wordlist&gt;
</pre>
		<p>现在，您可以在文字处理器或类似程序中创建和编辑 XML 文件以创建自己的单词列表。假以时日，我想信您一定会创建出一些有趣的主题单词列表。难道您不希望与他人分享您的成果吗？您不希望使用其他人创建的单词列表，也许用来猜出更难的单词？好消息是，我们几乎实现了这一功能。坏消息是，我不会像现在这样指导您完成每个步骤。首先，您应该按照与创建 Open File List 命令相同的方式创建新菜单项（可能称为 Download File List）。为相应的 actionPerformed 操作添加一种方法（与前面一样），然后使用下面的代码实现所说的方法：</p>
<pre class='examplecode'>
    private void downloadNewListMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
	String listURL;
	String prompt = &quot;Enter the URL to an XML word list:&quot;;
	String initialValue = &quot;http://&quot;;

	listURL = (String) javax.swing.JOptionPane.showInputDialog(prompt, initialValue);

	/* Perform some simple validation before attempting to download the new word list */
	if (listURL != null &amp;&amp; listURL.length() &gt; 0 &amp;&amp; listURL != initialValue)
	{
	    this.loadWordList(listURL);
	}
     }
</pre>
		<p>本文中介绍的内容就这些，但我希望您会看到使用 NetBeans 窗体设计器生成正确规范的图形用户界面代码是多么简单高效！当然啦，我们只是提供了一些粗浅的见解，但不管怎么说，我们使用有效的方法改进了 AnagramGame 应用程序，您现在有了一个非常简单的平台，您可以在上面试验新的概念和了解 NetBeans 功能。如果实现了自己的想法，您一定会非常开心，但在开始时要注意下面的问题：</p>
		<ol>
			<li>可以选择为每个单词列表提供一个标题属性，应用程序可能会在窗口标题中显示当前单词列表的名称。</li>
			<li>如果单词列表不是很大，在尝试有限的次数后，就会重复出现相同的单词，从而使游戏很容易预测而变得索然无味了。要解决该问题，您可以实现一个缓存以存储最近使用的单词。对于每个新的单词请求，请检查该缓存中是否该单词；如果有，则请求一个新单词，直到收到缓存中不包含的单词为止。这可确保不会出现太多的重复单词。从用户角度看，我认为如果缓存太小就无法降低重复几率，但缓存必须始终小于列表中的单词数，否则，将会出现无限循环。</li>
			<li>您可以创建一个不同的单词列表加载器以接受任何文本文档。该加载器分析所有字符串标记文本，并创建包含所有唯一单词的新单词列表，可能要求达到每个单词的最低字符数。将该加载器指向外国新闻网站，玩真正有挑战性的游戏！</li>
		</ol>


		<h2><a name="files">相关文件列表</a></h2>
			<table>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/306/anagrams.jar">anagrams.jar</a></td>
				<td>修改后的 AnagramGame 应用程序，采用可执行的 JAR 文件形式。单击以开始玩游戏！</td>
			</tr>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/305/simplelist.xml">simplelist.xml</a></td>
				<td>示例单词列表，采用 XML 文档形式。</td>
			</tr>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/307/WordListFileLoader.java">WordListFileLoader.java &nbsp;</a></td>
				<td>基于 SAX 的 XML 单词列表分析器。</td>
			</tr>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/304/anagrams-src.zip">anagrams-src.zip</a></td>
				<td>修改后的 AnagramGame 应用程序的完整 Java 源代码。</td>
			</tr>
		</table>

		<p></p>
	</body>
</html>
