<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>FeedReader</TITLE>
	
	<link rel="stylesheet" type="text/css" href="../../netbeans.css">
	<STYLE>
	<!--
		@page { size: 8.5in 11in }
		PRE { color: #808000 }
		P.boxnote { margin-left: 0.2in; margin-right: 0.2in; margin-top: 0.2in; margin-bottom: 0.2in; border: 1.00pt solid #9999cc; padding: 0.1in; color: #666699 }
		BLOCKQUOTE.western { font-style: italic }
	-->
	</STYLE>
</HEAD>
<BODY >
<H1>FeedReader</H1>
<b>Author: Rich Unger</b>
<br><i>This article was submitted as part of the Win With NetBeans contest.</i>
<p></p>
<H2 >A NetBeans Platform Sample and Tutorial</H2>

<P><IMG SRC="../../images_www/articles/win-with-netbeans/feedreader-branded.jpg" NAME="Finished FeedReader" ALIGN=MIDDLE WIDTH=957 HEIGHT=714 BORDER=0>
</P>
<h2>What does FeedReader do?</h2>
<P>FeedReader is a basic RSS/Atom feed browser, modeled after the
<A HREF="https://addons.mozilla.org/de/firefox/addon/77/">Sage</A> plugin for Mozilla
Firefox. It consists of:</P>
<UL>
	<LI><P>A list of feeds (URLs to rss/rdf/atom descriptor files)</P>
	<LI><P>A list of headlines from each feed</P>
	<LI><P>A browser window (mozilla embedded in a JFrame)</P>
</UL>
<P>The embedded mozilla frame is provided by the <A HREF="http://jdic.dev.java.net/">JDIC</A>
library, which uses JNI calls. I have configured this example to use
both the linux and windows versions of the JDIC binaries.</P>
<H3>Who Is This Tutorial For?</H3>
<P>The primary audience is, of course, people who want to build
applications on the NetBeans platform. I will attempt to fully
document how I created FeedReader, and what each line in the
manifests, layer files, and java source does, especially in cases
where I had to do something ... a little bit quirky.</P>
<P>That is the secondary reason for this tutorial. Quirkiness and odd
workarounds will be called out with a “Quirk Box”:</P>
<P CLASS="boxnote">You have to do something quirky to get this done.</P>
<P>In all such cases, I will link to the appropriate open issue in
IssueZilla. Hopefully, this can be a living document, and these Quirk
Boxes can be eliminated over time, resulting in a platform for which
it is easier to create applications.</P>
<h2>Getting Started</h2>
<P>Full <A HREF="https://netbeans.org/files/documents/4/296/feedreader-source.zip">source code</A> is available.</P>
<P>For the purposes of this tutorial, I am not going to assume any
particular IDE. In fact, let's just say you've got a text editor, 
JDK 1.5.0 (a bug in 1.4.x prevents compilation of this sample, though it will <i>run</i> in 1.4.x), 
and Apache Ant 1.6.2 or greater. To simplify my command line
examples, I will assume bash (unix or cygwin). Translate to the
windows command line if you wish. That works fine, too.</P>
<P>I just don't want to mix you up talking about the NetBeans <b>IDE</b> and
the NetBeans <b>platform</b>. Follow this tutorial first. Undertand how
modules work. Then worry about tools (like the NetBeans IDE) to make building them a little
easier.</P>
<P>The first thing you need to get started is a copy of the NetBeans
platform. You don't need to build it from source code. You can just
download a <A HREF="/downloads/">binary
release</A> and unzip it somewhere. I put mine in
<FONT FACE="Courier, monospace">/home/rich/netbeans.</FONT></P>
<P>Next, it would be helpful to have some sample source code to get
you started. I started with my <A HREF="http://contrib.netbeans.org/files/documents/130/269/cluster_build_harness.zip">cluster
build harness</A>. It's convenient because it already has ant build
scripts for building and packaging modules, and it's got a starter
module called “snipe”. Of course, now that I've written this, you
could just as easily start your application with the source tree for
FeedReader. 
</P>
<P>I unzipped my harness to <FONT FACE="Courier, monospace">/home/rich/src/rss.</FONT></P>
<P>Finally, you need to configure your build scripts, so they know
where to find your netbeans platform installation:</P>
<P>Modify a few lines in
<FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/user.build.properties</FONT>:</P>
<PRE><FONT COLOR="#808000">netbeans.dest.dir=/home/rich/netbeans</FONT>
<FONT COLOR="#808000">clustername=rssreader1</FONT></PRE><P>
By convention, clusters are given version numbers at the end, though
it is not strictly required.</P>
<BLOCKQUOTE CLASS="western">Definition: A <B>cluster</B> is a set of
modules and associated resource files. A netbeans installation can be
made up of a set of clusters, which are selected when you launch
netbeans. The NetBeans IDE, for example, runs the platform4, ide4,
nb4.0, and extra clusters. The idea behind clusters is that you can
have one installation of the NetBeans platform, and many branded
applications sharing the same clusters. I could, for example, install
the rssreader1 cluster into a Netbeans IDE installation, and by
running 2 different launch scripts, I could get the IDE and the
FeedReader, each sharing the platform4 cluster, but otherwise being
completely separate applications.</BLOCKQUOTE>
<P>Next, modify a few lines in
<FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/user.cluster.properties</FONT>,
in order to bring the cluster name in synch with what we just
specified in <FONT FACE="Courier, monospace">user.build.properties</FONT>:</P>
<PRE>user.cluster=cluster.rssreader1
cluster.rssreader1.dir=rssreader1
cluster.rssreader1= snipe</PRE><P>
Now, I could run <B><FONT FACE="Courier, monospace">ant</FONT></B> in
the <FONT FACE="Courier, monospace">nbbuild/</FONT> directory, and
I'd have a directory <FONT FACE="Courier, monospace">/home/rich/netbeans/rssreader1</FONT>
which contains the snipe module. Of course, I don't want a snipe
module, so I then type <B><FONT FACE="Courier, monospace">ant clean</FONT></B>
to get rid of it.</P>
<P>It's time to move on to the modules we do want.</P>
<h2>Library Modules</h2>
<P>You could bundle the entire FeedReader application into a single
module. It's just not very ... well ... modular. It happens that
FeedReader requires the libraries JDOM, Rome, and JDIC. If you ever
want to extend this application with more modules that may use these
libraries, it would be better to depend on just the library module,
rather than the entire FeedReader. Also, you can make the library
modules autoloading.</P>
<BLOCKQUOTE CLASS="western">Definition: An <B>autoload</B> module is
a module that will be automatically loaded by NetBeans when it is
required (by another module). Until that happens, it won't take up
any memory at runtime.</BLOCKQUOTE>
<H4>Adding Modules to the Source Tree</H4>
<P>Whenever you add a new module, you need to let the build harness
know about it. Modify two files.</P>
<P><FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/user.cluster.properties:</FONT></P>
<PRE>cluster.rssreader1=snipe, \
                   anothermodule, \
                   yetanother</PRE><P>
This tells the build scripts which modules are in your cluster, so
they know how to build the cluster as a unit, and in which directory
to install the resulting jar files.</P>
<P><FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/modules.xml:</FONT></P>
<PRE>&lt;module&gt;
  &lt;path&gt;snipe&lt;/path&gt;
  &lt;cnb&gt;org.netbeans.modules.snipe&lt;/cnb&gt;
&lt;/module&gt;</PRE><P>
This maps the name of the directory containing the module source
code, with the name netbeans will know it by at runtime (“cnb”
stands for code-name-base).</P>
<H4>JDOM</H4>
<P>I assume most readers will know what JDOM is. It's an XML parsing
API, and the only reason FeedReader needs it is because the Rome
library uses it.</P>
<P>Start by adding “jdom” to the cluster list and 
</P>
<PRE>&lt;module&gt;
  &lt;path&gt;jdom&lt;/path&gt;
  &lt;cnb&gt;org.jdom.api&lt;/cnb&gt;
&lt;/module&gt;</PRE><P>
to the module list. Now, here's a rundown of the JDOM module file
list:</P>
<PRE>build.xml
manifest.mf
nbproject/project.xml
nbproject/project.properties
lib/jdom.jar
src/org/jdom/api/Bundle.properties</PRE><P>
Let's take these one at a time.</P>
<P><B>build.xml</B>: The build file starts by importing another build
file called projectized.xml. Most of the time, that's all you'll need
to have in your module's build file. However, in the JDOM module you
want to include jdom.jar in the module's packaging, in addition to
the module's own jar.</P>
<P CLASS="boxnote">Quirk #1: You shouldn't have to override the build
behavior in order to include additional libraries. You should be able
to declare such dependencies in the project.xml file and the build
scripts should know how to create the appropriate manifest entries
and include them in the nbm file.
<BR><BR><A HREF="https://netbeans.org/bugzilla/show_bug.cgi?id=52354">https://netbeans.org/bugzilla/show_bug.cgi?id=52354</A></P>
<P>So, override 2 targets. The “files-init” target is an exact
copy of the target from projectized.xml, with the addition of the
line:</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;include name=&quot;${nb.modules.dir}/ext/jdom.jar&quot;/&gt;</PRE><P>
The “files-init” target lets the build scripts know which files
belong with the module. These are the files that get deleted when you
run the “clean” target.  It is a convention that jars which are not modules go in the <FONT FACE="Courier, monospace">ext/</FONT> directory.
<p>The other target you need to override is
“netbeans-extra”. This is a hook provided by the build scripts to
give you a place to do things like copy files as part of the
deployment process.</P>
<PRE>&lt;target name=&quot;netbeans-extra&quot; depends=&quot;init&quot;&gt;
    &lt;mkdir dir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/ext&quot;/&gt;
    &lt;copy todir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/ext&quot;&gt;
      &lt;fileset dir=&quot;lib&quot;&gt;
        &lt;include name=&quot;jdom.jar&quot;/&gt;
      &lt;/fileset&gt;
    &lt;/copy&gt;
&lt;/target&gt;</PRE><P>
This copies the jdom.jar file to
<FONT FACE="Courier, monospace">/home/rich/netbeans/rssreader1/modules/ext.</FONT></P>
<P><FONT FACE="Times New Roman"><B>manifest.mf</B>: Every jar file
needs a manifest. A netbeans module is simply a jar file whose
manifest contains at least these two lines:</FONT></P>
<PRE>OpenIDE-Module: org.jdom.api/1
OpenIDE-Module-Specification-Version: 1.0</PRE><P>
The first line is just the name of the module, and, optionally, a
<I>release-version</I>. Notice that this name matches the &lt;cnb&gt;
(code-name-base) from the modules.xml file.</P>
<P STYLE="font-style: normal">The second line is the module's
<I>specification-version</I>.</P>
<BLOCKQUOTE CLASS="western">A word on version numbers... A module can
have 3 different version numbers: a <B>release-version</B>, a
<B>specification-version</B>, and an <B>implementation-version</B>. 
</BLOCKQUOTE>
<BLOCKQUOTE CLASS="western">Let's say, for example, that module A has
release-version 1, specification version 2.0, and
implementation-version beta3. Now, module B is going to declare a
dependency on module A (in its project.xml file). It <SPAN STYLE="text-decoration: none"><SPAN STYLE="font-style: normal">must
</SPAN>specify a release version of 1. It <SPAN STYLE="font-style: normal">may
optionally</SPAN> specify a dependency on speficiation version 2.0.
If it does, and the author of A releases a version 2.1, that's okay,
the dependency will still work. The contract is that the public API
classes exposed by module A (see project.xml's &lt;public-packages&gt;
element) will not break compatibility. A dependency on the
specification version only gives B access to those API classes. </SPAN>
</BLOCKQUOTE>
<BLOCKQUOTE CLASS="western" STYLE="text-decoration: none"><I>If
module B specifies a dependency on implementation-version beta3, it
will only work with that version of module A. However, it will have
access to all the public classes in module A. (If you're getting a
NoClassDefFoundException when you're running your module, it could be
because you're trying to access non-API classes without specifying an
implementation dependency.)</I></BLOCKQUOTE>
<P>Only 2 more lines in the manifest:</P>
<PRE>OpenIDE-Module-Localizing-Bundle: org/jdom/api/Bundle.properties
Class-Path: ext/jdom.jar</PRE><P>
The first line is completely optional. It points to a bundle
containing more manifest entries. These manifest entries are all
localizable strings, such as a display name and description for this
module.</P>
<P>The second line is the standard manifest Class-Path entry, which
puts the jdom.jar file in the classpath of the module's jar file.
Notice that the path “ext/jdom.jar” matches up with where you
copied jdom.jar in the build.xml file.</P>
<P CLASS="boxnote">Quirk #2: Shouldn't have to specify Class-Path. It
should be generated automatically (see Quirk #1).</P>
<P><B>nbproject/project.xml</B>: This is the file that tells the
build scripts (and the IDE if you're using it) how to generate
dependency delcarations and classpaths. Here, too, you must specify
the familiar &lt;code-name-base&gt; and &lt;path&gt; information.
Next, you must specify any dependencies on other modules. Now, seeing
as though there's no actual code in the module itself, and jdom.jar
doesn't require any other code outside the core JRE classes, there's
really no module dependencies to declare. Still, you should always
declare a dependency on the core OpenAPI classes:</P>
<PRE>&lt;dependency&gt;
  &lt;code-name-base&gt;org.openide&lt;/code-name-base&gt;
    &lt;build-prerequisite/&gt;
    &lt;compile-dependency/&gt;
    &lt;run-dependency&gt;
      &lt;release-version&gt;1&lt;/release-version&gt;
      &lt;specification-version&gt;4.5&lt;/specification-version&gt;
  &lt;/run-dependency&gt;
&lt;/dependency&gt;</PRE><P>
It's kind of a special case. If you don't specify this, with a recent
specification-version, NetBeans will assume this is an old module,
and automatically load a bunch of dependencies at runtime, for
backwards-compatibility purposes.</P>
<P>Next, you need to declare the module's <FONT FACE="Courier, monospace">&lt;public-packages&gt;</FONT>.
This serves two purposes: public packages are viewable to other
modules that declare dependencies on this module, and they constitute
the set of packages that will get javadocs generated when running the
“javadoc” ant target.</P>
<P>You can either specify each package individally:</P>
<PRE>&lt;public-packages&gt;
  &lt;package&gt;org.jdom&lt;/package&gt;
  &lt;package&gt;org.jdom.adapters&lt;/package&gt;
  &lt;package&gt;org.jdom.input&lt;/package&gt;
  ...
&lt;/public-packages&gt;</PRE><P>
Or, you can get the whole tree with one line:</P>
<PRE>&lt;public-packages&gt;
  &lt;subpackages&gt;org.jdom&lt;/subpackages&gt;
&lt;/public-packages&gt;</PRE><P>
However, this method doesn't work with the “javadoc” target.</P>
<P><B>project.properties</B>: A few more hints to the build
process...</P>
<PRE>is.autoload=true
cp.extra=lib/jdom.jar
module.javadoc.packages=org.jdom</PRE><P>
The first line makes this module an <I>autoload</I> module. The
second line is appended to the compilation classpath. The third line
is required if you used the <FONT FACE="Courier, monospace">&lt;subpackages&gt;</FONT>
method to declare your <FONT FACE="Courier, monospace">&lt;public-packages&gt;</FONT>
in project.xml.</P>
<P CLASS="boxnote">Quirk #3: Specifying module.javadoc.packages
should not be necessary here. The build scripts should have a sane
backoff, with the assumption that the user isn't interested in
javadocs for this module. Right now, the build fails if this is not
specified.<BR><BR><A HREF="https://netbeans.org/bugzilla/show_bug.cgi?id=52135">https://netbeans.org/bugzilla/show_bug.cgi?id=52135</A>
<br><br>* Update: Fixed for NetBeans 4.1</P>
<h3 class='tutorial'>Rome</h3>
<H3>Rome</H3>
<P>The <A HREF="http://rome.dev.java.net/">Rome</A> library reads
RSS and Atom feeds (with a very simple API, I might add). The Rome
module and the JDOM module differ in only two respects. The Rome
module bundles two jar files (rome-0.4.jar and rome-fetcher-0.4.jar)
instead of one, and project.xml declares a dependency on the JDOM
module:</P>
<PRE>&lt;dependency&gt;
  &lt;code-name-base&gt;org.jdom.api&lt;/code-name-base&gt;
  &lt;build-prerequisite/&gt;
  &lt;compile-dependency/&gt;
  &lt;run-dependency&gt;
    &lt;release-version&gt;1&lt;/release-version&gt;
    &lt;specification-version&gt;1.0&lt;/specification-version&gt;
  &lt;/run-dependency&gt;
&lt;/dependency&gt;</PRE><H3>
JDIC</H3>
<P>The <A HREF="http://jdic.dev.java.net/">JDIC</A> library allows
java programs to take advantage of certain native desktop facilities
such as browsers, mailers, system trays, and MIME type registries.
FeedReader uses the embedded native browser component to render web
pages in a JFrame with the IE or Mozilla rendering engine.</P>
<P>In order to accomplish this, JDIC makes Java Native Interface
(JNI) calls to its shared library (<FONT FACE="Courier, monospace">jdic.dll</FONT>
or <FONT FACE="Courier, monospace">libjdic.so</FONT>), as well as run
native executables (<FONT FACE="Courier, monospace">IeEmbed.exe</FONT>
or <FONT FACE="Courier, monospace">mozembed-linux-gtk2</FONT>). You
need to do a little magic in the module's build file to make these
libraries and executables available to netbeans at runtime.</P>
<P>Notice the set of files declared in the “files-init” task:</P>
<PRE>&lt;include name=&quot;${nb.modules.dir}/ext/jdic.jar&quot;/&gt;
&lt;include name=&quot;lib/libjdic.so&quot;/&gt;
&lt;include name=&quot;lib/libmozembed-linux-gtk1.2.so&quot;/&gt;
&lt;include name=&quot;lib/libmozembed-linux-gtk2.so&quot;/&gt;
&lt;include name=&quot;lib/mozembed-linux-gtk1.2&quot;/&gt;
&lt;include name=&quot;lib/mozembed-linux-gtk2&quot;/&gt;
&lt;include name=&quot;lib/jdic.dll&quot;/&gt;
&lt;include name=&quot;lib/IeEmbed.exe&quot;/&gt;
&lt;include name=&quot;lib/nspr4.dll&quot;/&gt;
&lt;include name=&quot;bin/${shell.script}&quot;/&gt;
&lt;include name=&quot;bin/${batch.script}&quot;/&gt;</PRE><P>
Aside from the familiar jar file declaration, there are a list of
native libraries and executables in <FONT FACE="Courier, monospace">lib/</FONT>
and a pair of scripts. The decision to put the native stuff in this
particular directory is somewhat arbitrary, though it is the
suggested location in the <A HREF="http://openide.netbeans.org/proposals/arch/installation.html#logical">architecture
document</A>.  The only other thing that needs to know this location
is the startup scripts.</P>
<P>The shell script and batch script are generated by the <FONT FACE="Courier, monospace">shellscript</FONT>
target of the build file. These scripts launch the NetBeans platform
with the rssreader1 cluster and the jdic binaries in their proper
paths.</P>
<h2>FeedReader Module</h2>
<P>Now that you've got all the library modules you need, you're ready
to make a module that actually <I>does</I> something.</P>
<P STYLE="font-style: normal">Start by creating the build scripts and
declarative elements of the module. The <FONT FACE="Courier, monospace">build.xml</FONT>
file is blissfully empty, other than the import line for the standard
“projectized.xml”. The <FONT FACE="Courier, monospace">nbproject/project.xml</FONT>
file simply declares dependencies on your 3 library modules, and has
no public packages (this modules provides no API to other modules).
The <FONT FACE="Courier, monospace">nbproject/project.properties</FONT>
file is also empty. The <FONT FACE="Courier, monospace">manifest.mf
</FONT>file should look pretty familiar, too. There's only one new
element there:</P>
<PRE STYLE="margin-bottom: 0.2in">OpenIDE-Module-Layer: org/netbeans/modules/feedreader/resources/layer.xml</PRE><P>
Unlike the library modules, you're going to declare things about the
FeedReader's user interface in a layer file, for inclusion in the
“system filesystem.”</P>
<BLOCKQUOTE CLASS="western">Definition: The <B>system filesystem</B> is 
where NetBeans stores all the system settings, GUI layout information, 
actions, templates, and just about anything else required to maintain the state
of a NetBeans installation.  It is comprised of real files located under the "config" directory of
each cluster, the "config" directory of the NetBeans user directory, and virtual "files" declared in module
layer files.
</BLOCKQUOTE>
<h3 class='tutorial'>Layer File</h3>
<P>The first entry is under the top level folder called <FONT FACE="Courier, monospace">Actions</FONT>.
This is a repository for implementations of <FONT FACE="Courier, monospace">javax.swing.Action</FONT>.
They can be used for menu items, toolbar buttons, and keyboard
shortcuts. Adding this entry will allow users to assign keyboard
shortcuts to the ViewFeedsAction by selecting “Tools ... Keyboard
Shortcuts” from the menu.</P>
<P>The second entry puts the ViewFeedsAction under the “View”
menu. Notice the shadow file syntax, which is like using a soft link
in UNIX, or a shortcut in Windows.</P>
<P>The rest of the entries fall under the <FONT FACE="Courier, monospace">Windows2</FONT>
top level folder. This folder provides the platform with information
about what types of <A HREF="https://netbeans.org/download/4_0/javadoc/OpenAPIs/org/openide/windows/doc-files/api.html#overview-top">TopComponent</A>s
are going to be instantiated, and where to put them. (Incidentally,
this is called “Windows2” because “Windows” is the old,
pre-3.6 window system, which is kept around for backwards
compatibility reasons.) FeedReader contains two TopComponent
definitions: SiteListComponent and EntryListComponent. The latter is
meant to be opened in the default location (the center), so nothing
is necessary in the layer file to override this behavior.</P>
<P>The <FONT FACE="Courier, monospace">SiteListComponent</FONT>,
however, is meant to be docked on the left side, or the “explorer”
mode. So, add an entry:</P>
<PRE>&lt;folder name=&quot;Modes&quot;&gt;
    &lt;folder name=&quot;explorer&quot;&gt;            
        &lt;file name=&quot;rss_list.wstcref&quot; url=&quot;feedList.wstcref&quot;/&gt;
    &lt;/folder&gt;
&lt;/folder&gt;</PRE><P>
This declares that a <FONT FACE="Courier, monospace">TopComponent</FONT>
with id “rss_list” will be docked, by default, in the “explorer”
mode. (Incidentally, the extension “wstcref” stands for <I>Window
System Top Component REFerence</I>.) The placement of “rss_list”
within the declared mode is derived from the file <FONT FACE="Courier, monospace">feedList.wstcref</FONT>:</P>
<PRE>&lt;tc-ref version=&quot;2.0&quot;&gt;
    &lt;module name=&quot;org.netbeans.modules.feedreader/1&quot; spec=&quot;1.0&quot; /&gt;
    &lt;tc-id id=&quot;rss_list&quot; /&gt;
    &lt;state opened=&quot;true&quot; /&gt;
&lt;/tc-ref&gt;</PRE><P>
the value of <FONT FACE="Courier, monospace">&lt;tc-id id&gt;</FONT>
must match the basename of the file declared in the layer
(“rss_list”). The same name must also be present in the
<FONT FACE="Courier, monospace">Windows2/Components</FONT> folder
with a “.settings” extension:</P>
<PRE>&lt;folder name=&quot;Components&quot;&gt;
    &lt;file name=&quot;rss_list.settings&quot; url=&quot;feedList.settings&quot; /&gt;
&lt;/folder&gt;</PRE><P>
The contents of the settings file tells NetBeans how to instantiate
an “rss_list”. You can write the contents of this file by hand,
or you can comment out the entire Windows2 section of this layer
file, start up netbeans, instantiate a <FONT FACE="Courier, monospace">SiteListComponent</FONT>
by running the <FONT FACE="Courier, monospace">ViewFeedsAction</FONT>,
and grab the settings file that gets autogenerated in
<FONT FACE="Courier, monospace">$userdir/config/Windows2Local/Component</FONT>.
Then replace the <FONT FACE="Courier, monospace">&lt;serialdata&gt;</FONT>
section with:</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;instance class=&quot;org.netbeans.modules.feedreader.SiteListComponent&quot;/&gt;</PRE><P>
This creates the component using the default constructor of
<FONT FACE="Courier, monospace">SiteListComponent</FONT>. If the
class required a static factory method, you could add a method
attribute:</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;instance class=&quot;org.netbeans.modules.feedreader.SiteListComponent&quot; method=”makeSiteListComponent”/&gt;</PRE><H4>
ViewFeedsAction.java</H4>
<P>Now all that's left to do is the actual java code. The first class
declared in the layer file is <FONT FACE="Courier, monospace">ViewFeedsAction.java</FONT>.
This is a simple subclass of <FONT FACE="Courier, monospace">CallableSystemAction</FONT>,
which is a singleton implementation of <FONT FACE="Courier, monospace">javax.swing.Action</FONT>.</P>
<PRE>    public void performAction() {
        SiteListComponent.activate();
    }</PRE><P>
Performing this action will open and give focus to the singleton
instance of SiteListComponent (see implementation of
SiteListComponent below).</P>
<PRE>    public String getName() {
        return NbBundle.getMessage(SiteListComponent.class, &quot;SLC_title&quot;);
    }</PRE><P>
The name of the action is stored in Bundle.properties, so it can be
localized.</P>
<PRE>    public HelpCtx getHelpCtx() {
        return HelpCtx.DEFAULT_HELP;
    }</PRE><P>
You would change this if you had a JavaHelp id or a URL with more
specific help for this action.</P>
<PRE>    protected boolean asynchronous() {
        return false;
    }</PRE><P>
See the <A HREF="https://netbeans.org/download/4_0/javadoc/OpenAPIs/org/openide/util/actions/CallableSystemAction.html#asynchronous()">javadoc
entry</A> for more details.</P>
<h3 class='tutorial'>SiteListComponent.java</h3>
<P CLASS="boxnote">Quirk #4: Some of the more confusing code in this
class (the stuff dealing with IDs) has to do with ensuring a
singleton instance of SiteListComponent, with the id specified in the
layer file. Ideally, there should be a subclass of TopComponent
called something like SingletonTopComponent, as this seems like a
common thing to want to
do.<BR><BR><A HREF="https://netbeans.org/bugzilla/show_bug.cgi?id=53252">https://netbeans.org/bugzilla/show_bug.cgi?id=53252</A></P>
<P>The following code ensures a singleton:</P>
<PRE>    /** A hint to the window system for generating a unique id */
    private static final String PREFERRED_ID = &quot;rss_list&quot;; // NOI18N
    
    /** The actual id of the (singleton) instance */
    private static String s_id = PREFERRED_ID;

    ...

    public static synchronized SiteListComponent getInstance()
    {
        TopComponent c;
        c = WindowManager.getDefault().findTopComponent(s_id);
        if (c == null)
        {
            c = new SiteListComponent();
            s_id = WindowManager.getDefault().findTopComponentID(c);
        }
        return (SiteListComponent)c;
    }

    ...

    protected String preferredID() { 
        return PREFERRED_ID;
    }</PRE><P>
NetBeans maintains a map of all the <FONT FACE="Courier, monospace">TopComponent</FONT>s
currently in memory. The key to this map is what I'm referring to as
the “ID”. the “preferred” ID is just a hint to the window
system to be used when creating a new instance. There's <I>no
guarantee</I> that this hint does anything. It's generally just
useful so you can recognize the name of the component if you're
tracking down problems by perusing the contents of
<FONT FACE="Courier, monospace">$userdir/config/Windows2Local</FONT>.</P>
<P STYLE="font-style: normal">The static field <FONT FACE="Courier, monospace">s_id</FONT>,
however, is meant to be the ID of the one instance of
<FONT FACE="Courier, monospace">SiteListComponent</FONT> in memory.
It defaults to “rss_list” because that's the value of the ID
given in <FONT FACE="Courier, monospace">feedList.wstcref</FONT>. So,
if this is the first time the user uses this module, the component
with ID “rss_list” will be instantiated declaratively. However,
if the user closes that component, restarts NetBeans, and then
invokes the <FONT FACE="Courier, monospace">ViewFeedsAction</FONT>,
the new component may have a different ID. This is why the
getInstance() method may assign a new value to s_id.</P>
<P STYLE="font-style: normal">If the ID does change, there's nothing
in the layer file to insist that the new component be docked in the
“explorer” mode. To force this, override the open() method:</P>
<PRE>    private static final String MODE = &quot;explorer&quot;; // NOI18N

    public void open()
    {
        Mode m = WindowManager.getDefault().findMode(MODE);
        m.dockInto(this);
        super.open();
    }</PRE><P>
The rest of this class is not NetBeans-specific. The component
consists of a JList and two buttons: one to add a new feed, and one
to delete a selected feed. The list is backed by a SiteListModel.</P>
<h3 class='tutorial'>SiteListModel</h3>
<P>The <FONT FACE="Courier, monospace">SiteListModel</FONT> class
adds only serialization to the swing <FONT FACE="Courier, monospace">DefaultListModel</FONT>.
Upon construction, it loads the list of feeds from disk. It updates
the list on disk with each edit of the list. (Overkill? Perhaps, but
it's not going to be a very long list, and once the user sets it up
once, edits will be infrequent.)</P>
<P>The important bit is deciding <I>where</I> to serialize the list.
By putting it in the system filesystem, you can make the serialized
file part of the file structure in <FONT FACE="Courier, monospace">$userdir/config</FONT>:</P>
<PRE>    private static final String DIR = &quot;FeedReader&quot;; //NOI18N
    private static final String FILENAME = &quot;feeds.ser&quot;; //NOI18N

    private FileObject getSerializedFile(boolean create) throws IOException
    {
        FileSystem sysFs = Repository.getDefault().getDefaultFileSystem();
        FileObject dir = sysFs.findResource(DIR);
        if (dir == null)
        {
            if (create)
                dir = sysFs.getRoot().createFolder(DIR);
            else
                return null;
        }
        
        FileObject fo = dir.getFileObject(FILENAME);
        if (fo == null)
        {
            if (create)
                fo = dir.createData(FILENAME);
            else
                return null;
        }
        
        return fo;
    }</PRE><P>
The boolean parameter <FONT FACE="Courier, monospace">create</FONT>
will determine whether you want to create the file if it's not
already there (true for writing, false for reading).</P>
<P>So, the serialized list will end up in
<FONT FACE="Courier, monospace">$userdir/config/FeedReader/feeds.ser</FONT>.</P>
<P>This is a somewhat low-level approach to writing out the list of
feeds. There is, in fact, a NetBeans API that takes care of some of
this for you. You could implement the serialization by subclassing
<FONT FACE="Courier, monospace">SystemOption</FONT>, and just
override <FONT FACE="Courier, monospace">readExternal()</FONT> and
<FONT FACE="Courier, monospace">writeExternal()</FONT>. I chose to
write directly to the system filesystem to give you a better idea of
what's going on under the hood. Also, this implementation gives you
more flexibility to use a different file format. Once you've got the
<FONT FACE="Courier, monospace">FileObject</FONT> returned from
<FONT FACE="Courier, monospace">getSerializedFile()</FONT>, you could
write XML data to it as easily as using <FONT FACE="Courier, monospace">ObjectOutputStream</FONT>.</P>
<H4>EntryListComponent</H4>
<P><FONT FACE="Times New Roman">This class defines a component that
will open up in the center, or “editor”, mode, and contain a list
of news items from a single feed.</FONT></P>
<PRE>public class EntryListComponent extends TopComponent 
{
    protected static final String PREFERRED_ID = &quot;rss_entry_list&quot;; //NOI18N
    
    protected String preferredID() { 
        return PREFERRED_ID;
    } </PRE><P>
There's nothing funky going on with the IDs in this class. They're
just acting as hints to the window system.</P>
<PRE>    public static TopComponent getInstance(Feed feed)
    {
        // look for an open instance containing this feed
        Iterator opened = TopComponent.getRegistry().getOpened().iterator();
        while (opened.hasNext())
        {
            Object tc = opened.next();
            if (tc instanceof EntryListComponent)
            {
                EntryListComponent elc = (EntryListComponent)tc;
                if (feed.equals(elc.m_feed))
                {
                    elc.initData(feed);
                    return elc;
                }
            }
        }
        
        // none found, make a new one
        return new EntryListComponent(feed);
    }</PRE><P>
The <FONT FACE="Courier, monospace">getInstance()</FONT> method
ensures that only one instance exists for each unique feed. So, there
may be several tabs open at once, but only one for each feed URL.</P>
<PRE>    
    protected EntryListComponent(Feed feed) 
    {
        super();
        initComponents();
        if (feed != null)
            initData(feed);
    }</PRE><P>
Make the constructor protected, so clients have to use <FONT FACE="Courier, monospace">getInstance()</FONT>.</P>
<PRE>    
    protected void initData(Feed feed)
    {
        m_list.setFeed(feed);
        setDisplayName(feed.toString());
        
        m_feed = feed;
    }</PRE><P>
Give the feed to the <FONT FACE="Courier, monospace">JList</FONT>,
and set the display name, which will be used on the components tab,
and in window menus, etc.</P>
<PRE>    public int getPersistenceType() {
        return PERSISTENCE_NEVER;
    }</PRE><P>
When shutting down netbeans, don't bother serializing these
components.</P>
<h3 class='tutorial'>EntryList, BrowserFrame, Feed</h3>
<P>These classes don't contain much NetBeans-specific code. I'll let
the in-code comments speak for themselves.</P>
<h2>Try it Out!</h2>
<P>In the <FONT FACE="Courier, monospace">nbbuild/</FONT> directory,
run <B><FONT FACE="Courier, monospace">ant</FONT></B>. Then run
<B><FONT FACE="Courier, monospace">/home/rich/netbeans/rssreader1/bin/rss-reader.sh</FONT></B>
(or <B><FONT FACE="Courier, monospace">rss-reader.bat</FONT></B> on
Windows). You should now see an empty list on the left, to which you
can add feed URLs.</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><IMG SRC="../../images_www/articles/win-with-netbeans/feedreader-nobrand.jpg" NAME="Unbranded FeedReader" ALIGN=MIDDLE WIDTH=957 HEIGHT=714 BORDER=0></P>
<P>A working FeedReader! There's just one thing wrong. It still looks
like RSS capability tacked onto NetBeans. There are still toolbar
buttons and menu items that don't do anything useful for RSS reading.</P>
<h2>Branding</h2>
<P>FeedReader's branding module is a pretty simple module. There's no
java code at all. Just a layer file that hides a bunch of unused
toolbar and menu items:</P>
<PRE>    &lt;folder name=&quot;Toolbars&quot;&gt;
        &lt;folder name=&quot;File_hidden&quot;/&gt;
        &lt;folder name=&quot;Edit_hidden&quot;/&gt;
    &lt;/folder&gt;
    
    &lt;folder name=&quot;Menu&quot;&gt;
        &lt;folder name=&quot;File&quot;&gt;
            &lt;file name=&quot;org-openide-actions-SaveAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-openide-actions-SaveAllAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-netbeans-core-actions-RefreshAllFilesystemsAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-openide-actions-PageSetupAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-openide-actions-PrintAction.instance_hidden&quot;/&gt;
        &lt;/folder&gt;
        
        &lt;folder name=&quot;Edit_hidden&quot;/&gt;
        
        &lt;folder name=&quot;View&quot;&gt;
            &lt;!-- hide the default web browser that doesn't render stuff very well --&gt;
            &lt;file name=&quot;org-netbeans-core-actions-HTMLViewAction.instance_hidden&quot;/&gt;
        &lt;/folder&gt;
        
        &lt;folder name=&quot;Window&quot;&gt;
            &lt;file name=&quot;org-netbeans-core-actions-GlobalPropertiesAction.instance_hidden&quot;/&gt;
        &lt;/folder&gt;
    &lt;/folder&gt;</PRE><P>
The question I'm sure you're thinking is, “How did he know the
names of all those files to hide?” It certainly isn't obvious that,
to hide the “File ... Save” menu item, you need to specify <FONT FACE="Courier, monospace">&lt;file
name=”org-openide-actions-SaveAction.instance_hidden”/&gt;</FONT>.
Well, there's two ways. You can hunt around the netbeans source code,
looking for the layer file in which it was originally declared. Or,
you can use the Bean Browser, a tool included in the “Open APIs
Support” (org-netbeans-modules-apisupport) module on the NetBeans
Update Center. This creates a node in the “Windows...Runtime”
window called “Bean Browser” which lets you browse the system
filesystem. 
</P>
<P>Very useful little tool.</P>
<P>Aside from the layer file, there is one other unusual aspect to
the branding module. In the build script, you'll see the now-familiar
sections which add resource files to the deployed file set:</P>
<PRE>    &lt;!-- 
    Identifies all the files to be considered part of this module when deployed 
    --&gt;
    &lt;target name=&quot;files-init&quot; depends=&quot;basic-init&quot;&gt;
        &lt;patternset id=&quot;module.files&quot;&gt;
            &lt;include name=&quot;${module.jar}&quot;/&gt;
            &lt;include name=&quot;${javahelp.jar}&quot; if=&quot;has.javahelp&quot;/&gt;
            &lt;include name=&quot;${nb.system.dir}/Modules/${code.name.base.dashes}.xml&quot;/&gt;

            &lt;!-- additions for FeedReader begin here --&gt;
            &lt;include name=&quot;${nb.lib.dir}/locale/core_rss.jar&quot;/&gt;
            &lt;include name=&quot;${nb.modules.dir}/locale/org-netbeans-core-windows_rss.jar&quot;/&gt;
        &lt;/patternset&gt;
    &lt;/target&gt;

    &lt;!-- 
    netbeans-extra is a hook provided to plug in file copying. 
    --&gt;
    &lt;target name=&quot;netbeans-extra&quot; depends=&quot;init&quot;&gt;
        &lt;mkdir dir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.lib.dir}/locale&quot;/&gt;
        &lt;mkdir dir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/locale&quot;/&gt;

        &lt;jar destfile=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.lib.dir}/locale/core_rss.jar&quot; 
             basedir=&quot;core&quot;/&gt;
        &lt;jar destfile=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/locale/org-netbeans-core-windows_rss.jar&quot; 
             basedir=&quot;core-windows&quot;/&gt;
    &lt;/target&gt;</PRE><P>
In this case, you're adding two jar files: <FONT FACE="Courier, monospace">core_rss.jar</FONT>
and <FONT FACE="Courier, monospace">org-netbeans-core-windows_rss.jar</FONT>.
These jars correspond to <FONT FACE="Courier, monospace">core.jar</FONT>
and <FONT FACE="Courier, monospace">org-netbeans-core-windows.jar</FONT>.
In fact, any jar in the standard netbeans install can be “branded”
by placing another jar relative to the original:</P>
<PRE>/path/to/original.jar
/path/to/locale/original_brandname.jar</PRE><P>
Recall that the shell script in the JDIC module passes “–branding
rss” as a parameter. So the “brandname” in this case is “rss”.</P>
<P>Just about any resource file can be branded. Icons, bundles, layer
files, etc. In <FONT FACE="Courier, monospace">core_rss.jar</FONT>,
I've branded the splash screen and a resource bundle, which contains
keys that affect how the splash screen is displayed. In
<FONT FACE="Courier, monospace">org-netbeans-core-windows_rss.jar</FONT>,
I've branded just one bundle, to override the main title bar's text.</P>
<h2>Try it Again!</h2>
<P>Now you should see a screen like the screenshot at the beginning
of this article. And now you know how to write a real application for
the NetBeans platform.</P>
<h2>Questions?</h2>
<P>Please direct questions to the <A HREF="mailto:dev@openide.netbeans.org">dev@openide.netbeans.org</A>
mailing list. See <A HREF="https://netbeans.org/community/lists/top.html">https://netbeans.org/community/lists/top.html</A>
for information on netbeans mailing lists.</P>
</BODY>
</HTML>

