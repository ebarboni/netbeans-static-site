<html>
	<head>
	  <META NAME="AUDIENCE" CONTENT="NBUSER">
	  <META NAME="TYPE" CONTENT="ARTICLE">
	  <META NAME="TOPIC" CONTENT="BASIC">
	  <META NAME="description" CONTENT="Getting Started with NetBeans and Java">
	  <link rel="stylesheet" type="text/css" href="../../netbeans.css">
		<title>Начало работы с NetBeans и Java</title>
		</head>
	<body>

		<h1>Начало работы с NetBeans и Java</h1>
<div class="articledate" style="margin-left:0px;">Автор &mdash; Бен Сатер (Ben Suter) в рамках соревнования <a href="../../competition/win-with-netbeans.html">Победа с NetBeans</a> </div></p>
		<p>Для работы со статьей требуется установить NetBeans 4.0 и пакет SDK Java (также называемый JDK).
		<!-- If you have not yet done so, please refer to <a href="https://netbeans.org/kb/articles/nb-install-sequence.html">this brief introduction</a>, which shows the step-by-step installation sequence for NetBeans.</p> -->

		<p>Сначала рассмотрим новую среду IDE и один из встроенных примеров приложений. В первом разделе, широко используются снимки экрана; с этим разделом можно работать сразу после установки NetBeans. Затем рассмотрим использование NetBeans для правки, компиляции и выполнения несложного приложения Java. По мере продвижения количество снимков экрана будет уменьшаться, а объем исходного кода &mdash; увеличиваться. Темп работы (расширения примера приложения &quot;игра в анаграммы&quot;) будет ускоряться по мере изучения расширенных возможностей NetBeans по повышению производительности труда. К концу статьи читатель познакомится с использованием NetBeans для написания кода Java для открытия и синтаксического анализа документов XML, запроса пользовательского ввода посредством простых диалоговых окон и многого другого. И, разумеется, будет сделан огромный шаг к самостоятельному созданию и расширению приложений Java. Поехали!</p>


		<ol>
			<li><a href="#1">Первые шаги: ознакомление с NetBeans и начало проекта</a></li>
			<li><a href="#2">Изменение исходного кода</a></li>
			<li><a href="#3">Слишком предсказуемо?</a></li>
			<li><a href="#4">Увесистая порция java.util.Random</a></li>
			<li><a href="#5">Загрузка списков слов из файлов</a></li>
			<li><a href="#files">Список связанных файлов</a></li>
		</ol>

		<h2><a name="1">Первые шаги: ознакомление с NetBeans и начало проекта</a></h2>

		<p>При первом запуске NetBeans из меню &quot;Пуск&quot; загрузка завершилась приблизительно за 15 секунд. В некоторых случаях первая загрузка может занять больше времени: NetBeans знакомится с системой. </p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-initial-splash.png" />
		<p>После загрузки можно осмотреться &mdash; в случае сомнений жмите &quot;Отмена&quot;! Для продолжения нажмите кнопку &quot;Пример проекта&quot; под приветственным изображением.</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-1-choose.png" />
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-2.png" />
		<p>По умолчанию в качестве местоположения проекта выбирается домашняя папка. Создайте папку &quot;code&quot; на диске C:, а в ней &mdash; папку &quot;java&quot;. Затем выберите эту созданную папку в качестве местоположения проекта с помощью кнопки &quot;Обзор&quot;, как показано на следующем снимке экрана.</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-3.png" />
		<p>После нажатия кнопки &quot;Готово&quot; в диалоговом окне выше открывается диалоговое окно &quot;Сканирование пути к классам&quot;, которое остается открытым приблизительно в течение минуты.</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-4-scanningclasspath.png" />
		<p>Теперь на вкладке &quot;Проекты&quot; на левой &quot;панели&quot; отображается единственный узел с заголовком &quot;AnagramGame&quot;. Приветственная заставка остается открытой в &quot;главной&quot; области. Разверните узел &quot;AnagramGame&quot; на вкладке &quot;Проекты&quot; и последовательно разверните все дочерние узлы, пока не станет видна следующая древовидная структура:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-projectstructure.png" />
		<p>На рисунке выше размер главного окна NetBeans изменен, и видна только левая &quot;панель&quot;.</p>
		<p>Заметим, что этот пример приложения состоит из двух &quot;исходных пакетов&quot; (один из них &mdash; библиотека, а второй &mdash; интерфейс пользователя) и одного &quot;тестового пакета&quot; (для библиотеки). Также необходимо отметить, что каждый класс кроме полей/конструкторов/методов содержит узел &quot;Шаблоны компонентов&quot; (для всех текущих классов, показанных выше, однако, этот узел пуст). В этой статье узлы &quot;Шаблон компонентов&quot; не используются, однако они весьма полезны для повышения модульности, кода, его гибкости и пригодности к повторному использованию посредством <a href="http://java.sun.com/products/javabeans/index.jsp">компонентов JavaBeans</a>.</p>
		<p>Дважды щелкните узел &quot;About.java&quot;; откроется следующая вкладка:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-about-designmode.png" />
		<p>Вкладку приветствия в главной области/панели можно закрыть. Снова предоставим читателю возможность свободно исследовать NetBeans: можно открывать файлы с открытым исходным кодом, просматривать визуальные &quot;формы&quot; для некоторых классов интерфейса пользователя или просматривать файлы, не содержащие исходного кода, путем переключения с вкладки &quot;Проекты&quot; на вкладку &quot;Файлы&quot; на левой панели. На этой панели можно просмотреть различные файлы .properties и скрипты построения Ant. Окно &quot;Параметры&quot;, вызываемое из меню &quot;Сервис&quot;, позволяет оценить гибкость и разнообразие возможностей настройки среды IDE! </p>
		<p>Теперь остановимся и еще раз отрепетируем закрытие и открытие NetBeans. На этот раз среда IDE откроется с пустой главной областью, а в области &quot;Проекты&quot; окажется проект &quot;AnagramGame&quot;. Теперь нажмите кнопку &quot;Выполнить главный проект (F6)&quot; на панели инструментов (она желто-зеленая; для просмотра заголовка кнопки наведите на нее курсор). В среде IDE NetBeans откроется окно &quot;Вывод&quot; со следующим текстом:</p>
<pre class='examplecode'>
init:
deps-jar:
Created dir: C:\code\java\AnagramGame\build\classes
Compiling 3 source files to C:\code\java\AnagramGame\build\classes
compile:
run:
</pre>
		<p>Кроме того, откроется небольшое окно &mdash; пользовательский интерфейс приложения AnagramGame.</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-game-1.png" />
		<p>Я сразу отгадал! Возможно, это связано с тем, что среди каталогов и файлов, просмотренных ранее, оказался длинный список слов (вероятно, расшифрованных слов), которые могли несколько упростить задачу. Запомним это на будущее...</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-game-2.png" />


		<h2><a name="2">Изменение исходного кода</a></h2>

		<p>Сначала просто изменим текст одного из сообщений, выводимых пользователю в примере приложения. На панели &quot;Проекты&quot; дважды щелкните узел com.toy.anagrams.ui.Anagrams. Его исходный код откроется в новой вкладке в главной области окна. В верхнем левом углу вкладки расположена кнопка &quot;Конструктор&quot; и &quot;Исходный кол&quot;. Нажмите кнопку &quot;Исходный файл&quot;, если она еще не нажата &mdash; откроется исходный код Java для класса Anagrams в редакторе. Щелкните правой кнопкой мыши левое поле и убедитесь в том, что установлен флажок &quot;Показать номера строк&quot;. Перейдите к строке №211 (нажмите сочетание клавиш CTRL+G). Строка должна выглядеть следующим образом:</p>
		<pre class='examplecode'>feedbackLabel.setText(&quot;Incorrect! Try again!&quot;);</pre>
		<p>Изменим текст (тривиально), скомпилируем его, выполним приложение, неправильно отгадаем слово и рассмотрим измененное сообщение. На рисунке показан пример нового сообщения:</p>
		<pre class='examplecode'>feedbackLabel.setText(&quot;Not quite ... please try again!&quot;);</pre>
		<p>На этот раз обратите внимание, что на вкладке редактора между словом &quot;Anagrams&quot; и &quot;X&quot; (команда закрытия) появилась маленькая звездочка. Эта звездочка означает, что файл изменен, но не сохранен. Сохраните изменения: Файл-&gt;Сохранить (или CTRL+S). Итак на данный момент исходный файл изменен и сохранен, однако в скомпилированном файле класса все еще старый код. NetBeans позволяет выполнить два действия разом: щелкните зеленый/желтый значок &quot;Выполнить главный проект&quot; или просто нажмите клавишу F6. Снова откроется приложение. В консоли вывода, однако отображается следующий текст:</p>
<pre class='examplecode'>
init:
deps-jar:
Compiling 1 source file to C:\code\java\AnagramGame\build\classes
compile:
run:
</pre>
		<p>Как видно, перед выполнением приложения NetBeans (точнее скрипт построения Ant) обнаружил, что файл изменен, и скомпилировал его перед выполнением &quot;задачи выполнения&quot;. Попытайтесь отгадать слово, желательно неправильно. Если все прошло правильно, появится сообщение с текстом, настроенным выше.</p>
		<p>Сыграйте пару раз; автор, например, не смог осилить &quot;iccrmutsnaec&quot;. Для демонстрации следующих важнейших возможностей NetBeans смухлюем и подсмотрим решение в исходном коде. Предположим, что перетасованные версии слов хранятся в одном из исходных файлов проекта, а не генерируются каждый раз случайным образом из исходного слова. Вскоре мы убедимся, что именно так и обстоят дела в текущей реализации; немного позднее мы примем меры по этому поводу...</p>
		<p>На вкладке &quot;Проекты&quot; щелкните правой кнопкой мыши узел &quot;Пакеты с исходными файлами&quot; и выберите пункт контекстного меню &quot;Поиск...&quot;. Откроется следующий экран с заголовком &quot;Поиск&quot;:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-find-1.png" />
		<p>На этом снимке экрана виден введенный критерий поиска &quot;iccrmutsnaec&quot;. Оставьте остальные параметры настройки без изменения и нажмите кнопку &quot;Поиск&quot; для запуска поиска. Рядом с консолью вывода откроется новая вкладка с результатами поиска. Как показано на рисунке, обнаружено одно совпадение &mdash; в файле &quot;WordLibrary.java&quot;, на строке №53:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-find-2.png" />
		<p>Дважды щелкните совпадение (узел, отмеченный как &quot;iccrmutsnaec&quot;, [позиция 63:10] выше). Соответствующий исходный файл откроется в редакторе, соответствующая строка будет переведена в поле зрения, и будет подсвечена совпадающая фраза. Оказывается, &quot;iccrmutsnaec&quot; &mdash; шестая запись в массиве строк; этот массив называется &quot;SCRAMBLED_WORD_LIST&quot;. Обратите внимание, что прямо над этим массивом расположен другой массив, однако записи в нем &mdash; нормальные английские слова. Этот массив называется &quot;WORD_LIST&quot;. Вероятно, к этому моменту все уже догадались, что решение для слова &quot;iccrmutsnaec&quot; &mdash; это шестая запись в массиве &quot;WORD_LIST&quot;. Разумеется, создатель приложения мог применить и менее очевидную схему отображения между расшифрованными и зашифрованными словами, однако к счастью он этого не сделал! Поэтому на строке №16 можно наблюдать слово &quot;circumstance&quot;. Введите это слово в приложение (если оно уже закрылось, повторите игру до требуемого момента); откроется следующий экран:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-game-3.png" />


		<h2><a name="3">Слишком предсказуемо?</a></h2>

		<p>Теперь мы знаем, как открыть файл для редактирования, изменить исходный код, скомпилировать и выполнить приложение, выполнить поиск по исходному коду и сжульничать в игре в анаграммы. Попытаемся объединить эти навыки, чтобы сделать приложение AnagramGame немного интереснее. Для этого реализуем динамическую генерацию перетасованных слов, избавившись таким образом от необходимости вести список перетасованных слов в исходном коде. В результате исчезнет одна из возможностей для жульничества. Затем обеспечим случайный характер генерируемых перетасованных слов, чтобы игра была поинтереснее.</p>
		<p>В исходном коде WordLibrary виден метод &quot;getScrambledWord&quot;. Рассмотрев этот метод, можно заметить, что его реализация чрезвычайно проста:</p>
		<pre class='examplecode'>return SCRAMBLED_WORD_LIST[idx];</pre>
		<p>В этом месте мы и будем вносить изменения. Начнем с изменения этой строки (№126) на следующую:</p>
		<pre class='examplecode'>return generateScrambledWord(idx);</pre>

		<p>Эта строка кода отмечается в среде IDE NetBeans подчеркиванием красной волнистой линией, что указывает на синтаксическую ошибку в исходном коде. Переместите курсор в любую часть подчеркнутого исходного кода: выводится небольшое сообщение о том, что сигнатура метода generateScrambledWord(int) не распознана. Разумеется, этот метод еще не создан. Создадим его. Метод просто добавляется в конец класса, начиная со строки №147:</p>
<pre class='examplecode'>
    /**
     * Поиск соответствующего слова в словаре для указанного индекса
     * и генерация перетасованной версии этого слова.
     * @param idx индекс тасуемого слова
     * @return перетасованная версия слова
     */
    protected static String generateScrambledWord(int idx)
    {
	int j = 0;
	String word;
	String scrambled = &quot;&quot;;
	java.util.Random r;

	r = new java.util.Random();
	word = getWord(idx);

	for (j = 0; j &lt;word.length(); j++)
	{
	    if ( r.nextBoolean() )
		scrambled = scrambled + word.charAt(j);
	    else
		scrambled = word.charAt(j) + scrambled;
	}

	return scrambled;
    }
</pre>
		<p>Задача функции generateScrambledWord(int) заключается в возврате перетасованной версии словарной записи, указанной целочисленным аргументом &mdash; индексом. Несомненно, можно придумать множество разных способов тасовки (изменения порядка) букв в слове, и читатель волен реализовать тело этого метода любым уместным способом. Можно, например, просто обратить порядок букв, но тогда игра станет, вероятно, слишком простой (тем не менее, попробуйте!). Также можно попарно переставить местами соседние буквы от начала до конца слова. Примените воображение и найдите алгоритм, интересный в реализации и выдающий интересные результаты. Остановимся на реализации, приведенной в примере. Встроенное средство генерации случайных чисел Java используется здесь таким образом, чтобы результат каждой тасовки определенного слова был всегда разным. Перетасованное слово конструируется побуквенно, причем каждая следующая буква добавляется в начало или в конец фрагмента слова в зависимости от выпавшего случайного числа. Таким образом формируется новое слово, состоящее из всех букв исходного слова, однако в новой и случайной последовательности. Теперь выполните полученное приложение. На этот раз автору не удалось угадать многие слова, однако из-за случайного характера составления последовательностей время от времени выпадает перетасованное слово, очень близкое к исходной форме. Для устранения этого недостатка можно, например, изменить алгоритм, приведенный выше, и изменять порядок пар символов, а не отдельных символов, из-за которых слова проще отгадать. Если у читателя получится алгоритм, делающий игру особенно увлекательной, просим поделиться им со всеми читателями статьи. </p>
		<p>Словарь перетасованных слов (массив SCRAMBLED_WORD_LIST) больше не используется, поэтому его можно смело удалить из исходного файла WordLibary.java (строки с 57 по 104).</p>


		<h2><a name="4">Увесистая порция java.util.Random</a></h2>

		<p>В новой версии игры угадать слово гораздо труднее. Автор, например, был совершенно фрустрирован такой сложностью. Что же делать? Известно, что исходные слова хранятся в простом словаре, также известно, что в ходе игры слова берутся из этого словаря поочередно, от начала до конца. Поэтому в текущем коде, так как мы имеем доступ к исходному файлу, мы все равно можем схитрить, отследив порядковый номер очередного слова и подсмотрев его в словаре. При запуске игры выпало слово &quot;noiatabsrct&quot;, которое автору не удалось сразу отгадать. Однако на строке №11 в файле WordLibrary.java видно, что первое слово &mdash; &quot;abstraction&quot;. Следующая задача &mdash; задать случайный порядок выборки слов из словаря. Для этого снова воспользуемся классом Random из пакета java.util. Поскольку этот класс используется уже второй раз, обратимся к документации по его интерфейсу API за базовыми сведениями о его функциях. </p>
		<p>Экземпляр этого класса используется для генерации потока псевдослучайных чисел. Используется 48-разрядное начальное число, которое изменяется по линейной конгруэнтной формуле. (Подробные сведения приведены в книге Дональда Кнута &quot;Искусство программирования&quot;, том 2, раздел 3.2.1). Если создать два экземпляра класса Random с одинаковыми начальными числами и вызывать их методы в одинаковой последовательности, будут получены идентичные последовательности числовых значений.</p>
		<p>Пока что ради удобства использовался конструктор java.util.Random без аргументов. Комментарии к интерфейсу API, приведенные выше, указывают на необходимость инициализации каждого экземпляра Random с уникальным начальным числом; в противном случае при повторном использовании приложения последовательность может повториться. Из <a href="http://java.sun.com/j2se/1.4.2/">документации</a> по конструктору без аргументов видно, что фактически в нем в качестве начального числа используется текущее время (в миллисекундах), так что существующий код пригоден к использованию, и можно перейти к более существенным вопросам. </p>
		<p>Какие изменения требуются для установления случайного порядка выборки слов из словаря? В классе WordLibrary есть два метода, относящихся к делу: как getWord(int idx), так и getScrambledWord(int idx) принимают в качестве параметра индекс слова в словаре. Разместите курсор на имени метода getWord, затем щелкните его и выберите пункт меню &quot;Поиск использований&quot;. Этот метод вызывается трижды (один раз из WordLibraryTest и два раза собственно из WordLibrary). Каждый из этих вызовов используется внутри компонента WordLibrary (в т.ч. в инфраструктуре тестирования), и здесь что-либо менять не требуется. Далее, переведите курсор на имя метода getScrambledWord и нажмите сочетание клавиш ALT+F7. Снова выводятся три случая использования метода, однако два из них &mdash; из класса Anagrams. Рассмотрим их подробнее. В обоих случаях (строки 28 и 195) значение параметра, передаваемого в getScrambledWord &mdash; переменная wordIdx. Сама переменная объявляется на строке 22 и инициализируется нулевым значением. Выполним поиск случаев использования переменной worldIdx: их три.</p>
		<ol>
			<li>На строке 28 конструктор игры выполняет начальное заполнение элемента управления перетасованных слов первым словом словаря.</li>
			<li>В методе nextTrialActionPerformed переменная wordIdx увеличивается на единицу (обратите внимание, что она сбрасывается до нуля после перебора всех слов), а затем элемент управления перетасованных слов заполняется новым значением в соответствии с этой переменной.</li>
			<li>В методе guessedWordActionPerformed выполняется обработка попытки пользователя, причем текущее значение переменной wordIdx используется для поиска соответствующего слова.</li>
		</ol>
		<p>Теперь мы видим, что переменная wordIdx определяет слово, выбираемое после каждой попытки, и эта переменная изменяется только в одном месте, в строке №192 файла Anagrams.java:</p>
		<pre class='examplecode'>wordIdx = (wordIdx + 1) % WordLibrary.getSize();</pre>
		<p>Для установления случайного порядка выборки слов из словаря необходимо изменить эту строку так, чтобы значение wordIdx было случайным и находилось между нижней и верхней границами словаря. Этого позволяет добиться метод java.util.Random.nextInt(int n), поэтому заменим строку №192 следующей строкой кода:</p>
		<pre class='examplecode'>wordIdx = new java.util.Random().nextInt(WordLibrary.getSize());</pre>
		<p>Проверим, достигнут ли требуемый эффект, т.е. сыграем снова! Первое слово уже не вызывает трудностей, это всегда перетасованное &quot;abstraction&quot;. В самом деле, конструктор Anagram в начале игры всегда выбирает первое слово из словаря, поскольку переменной wordIdx статически присваивается нулевое начальное значение. Однако после первого слова все следующие варианты непредсказуемы, что и требовалось. Следовательно, игра стала чуть интереснее, и остается всего один жульнический способ (разумеется, при наличии доступа к исходному коду). При желании можно также реализовать случайный характер выборки первого слова в игре. Для этого необходимо просто вычислить начальное значение переменной wordIdx тем же способом, что и последующие значения &mdash; строка №22 файла Anagrams.java теперь выглядит следующим образом:</p>
		<pre class='examplecode'>private int wordIdx = wordIdx = new java.util.Random().nextInt(WordLibrary.getSize());</pre>


		<h2><a name="5">Загрузка списков слов из файлов</a></h2>

		<p>Вероятно, у читателя также не вызовет затруднений слово &quot;elxical&quot; &mdash; перетасованное &quot;lexical&quot; &mdash; однако при виде &quot;lasiugsidintinhbe&quot; уже хочется нажать кнопку &quot;Новое слово&quot;. Почему &quot;indistinguishable&quot; в среднем сложнее, чем &quot;lexical&quot;? Чем меньше буев в исходном слове, тем более вероятно (при текущем алгоритме тасовки), что перетасованная форма будет мало отличаться от исходной. В более общем виде, однако, короткие слова проще расшифровать, чем длинные, независимо от алгоритма. Для начинающего игрока был бы интереснее набор коротких слов, а для опытного &mdash; длинных. Разумеется, кроме длины слова есть и другие признаки, например, редкость слова, часть речи, язык или тематика. Могут ли эти наблюдения сделать игру интереснее, и можно ли в процессе узнать что-нибудь новое о NetBeans и Java?</p>
		<p>В этом разделе словарь выносится из приложения, т.е. в игре можно использовать несколько разных списков слов, и пользователи даже могут предоставлять собственные списки слов. Для этого существует, разумеется, несколько способов; в данном случае эта функциональная возможность реализуется путем чтения файла со структурированным списком слов в формате XML. К концу раздела читатель познакомится с открытием и чтением файлов из локальной файловой системы или из веб-файлов и с эффективным синтаксическим анализом несложного файла XML. </p>

		<p>Для загрузки внешнего списка слов целесообразно добавить новый пункт меню. Для этого переключимся в режим проектирования. Выполним переход от такого представления:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-loadWordList.png" />
		<p>К такому:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-designMode.png" />
		<p>В режиме проектирования справа также отображается панель &quot;Инспектор&quot;. Сначала внешний вид панели следующий:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-form-inspector-initial.png" />
		<p>На панели &quot;Инспектор&quot; показана иерархическая структура компонентов Swing, составляющих графический интерфейс пользователя. Если развернуть узел [JFrame], видно, что первый компонент называется mainMenu [JMenuBar]. Он, в свою очередь, содержит в себе элемент fileMenu [JMenu], в который входят еще два узла: aboutMenuItem [JMenuItem] и exitMenuItem [JMenuItem]. Как видно, каждый узел обозначен именем соответствующей переменной; за ней следует тип компонента в квадратных скобках. Главный фрейм &mdash; это собственно класс Anagrams (наследник JFrame), поэтому в классе Inspector не показано имя экземпляра для этого первого компонента. Наша задача заключается в добавлении команды меню для загрузки внешнего списка слов, поэтому воспользуемся &quot;инспектором&quot; и новый элемент между позициями &quot;About&quot; (О программе) и &quot;Exit&quot; (Выход) в меню &quot;File&quot; (Файл).</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-form-inspector-addingMenuItem.png" />
		<p>Щелкните правой кнопкой мыши узел fileMenuItem и выберите &quot;Добавить&quot;, а затем &quot;JMenuItem&quot;. Новый пункт меню добавляется в третьей позиции после пункта &quot;Exit&quot;. Сначала в среде IDE NetBeans этому пункту присваивается автоматически созданное имя; изменим его на &quot;openNewListMenuItem&quot;. Для этого необходимо щелкнуть новый пункт правой кнопкой мыши и выбрать &quot;Переименовать&quot;. Наконец, снова щелкните правой кнопкой мыши новый пункт и выберите &quot;Переместить вверх&quot;: будет установлен требуемый порядок.</p>
		<p>Теперь выберите пункт exitMenuItem и нажмите кнопку &quot;Свойства&quot; на панели &quot;Свойства&quot; непосредственно под &quot;инспектором&quot;. Среди прочих здесь есть три интересных свойства: mnemonic, text, toolTipText. Для данного конкретного пункта меню значения этих свойств соответственно &quot;E&quot;, &quot;Exit&quot; и &quot;Quit Team, Quit!&quot;. Выберите новый пункт меню и измените значения его свойств на &quot;O&quot;, &quot;Open Word List&quot;, &quot;Choose a new word list file, replacing the current list.&quot; соответственно.</p>
		<p>Затем добавим код, который должен выполняться при выборе этого пункта меню пользователем. NetBeans снова спешит на помощь: щелкните правой кнопкой мыши в &quot;инспекторе&quot; узел openNewListMenuItem и выберите в раскрывающихся меню &quot;События&quot;, затем &quot;Действия&quot;, затем &quot;actionPerformed&quot;. После создания метода обработки событий будет выполнен переход обратно к представлению &quot;Исходный код&quot; для написания требуемой реализации. Новому методу автоматически присваивается имя &quot;openNewListMenuItemActionPerformed&quot;, однако его можно безопасным образом переименовать с помощью команды &quot;Реорганизация кода&quot;. Небольшое отступление для читателей, имеющих опыт работы со средствами проектирования графических интерфейсов пользователя Swing: какое же жизнеутверждающее зрелище представляет собой чистая и ладная структура, имена и форматирование автоматически сгенерированного кода! Например, код для трех пунктов в меню &quot;Файл&quot; приводится в том же порядке, что и сами пункты. Вернемся к делу. Когда пользователь выбирает пункт меню &quot;Open Word List&quot; (Открыть список слов), ему предлагается выбрать файл в локальной файловой системе, который затем открывается, синтаксически анализируется и используется как список слов. Если файл недоступен или не содержит действительного списка слов, игра продолжается с текущим списком слов. Вот с чего мы начинали:</p>
<pre class='examplecode'>
private void openNewListMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
// TODO собственный код обработки:
}
</pre>
		<p>Загрузчик принимает в качестве главного параметра адрес URL, поэтому необходимо сгенерировать адрес URL в соответствии с именем файла, выбранным пользователем. Сначала создадим экземпляр JFileChooser и откроем с его помощью диалоговое окно &quot;Открыть файл&quot;. Если пользователь выберет файл, сгенерируем соответствующий адрес URL путем добавления протокола file:/// к абсолютному пути к файлу.</p>
<pre class='examplecode'>
   private void openNewListMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
	/* Переменная &quot;initialDirectory&quot; определяет начальный отображаемый каталог
	 * при выборе списка слов. В случае указания пустой строки обзор начнется
	 * с каталога по умолчанию для пользователя. В Windows это обычно &quot;Мои Документы&quot;,
	 * а в *nix &mdash; домашний каталог пользователя.
	 */
	String initialDirectory = &quot;&quot;;
	String fileURL;
	JFileChooser chooser;
	int returnVal;

	chooser = new JFileChooser(initialDirectory);
	returnVal = chooser.showOpenDialog((Component) evt.getSource());

	if ( returnVal == chooser.APPROVE_OPTION )
	{
	    /* Для создания адреса URL для файла в локальной файловой системе просто 
	     * добавим в начало абсолютного пути к файлу протокол &quot;file&quot;.
	     */
	    fileURL = &quot;file:///&quot; + chooser.getSelectedFile().getAbsolutePath();
	    this.loadWordList(fileURL);
	}
    }
</pre>
		<p>Показанный выше метод иллюстрирует предоставление пользователю диалогового окна выбора файлов; затем вызывается пока неопознанный метод loadWordList. Этот метод принимает в качестве параметра файл со списком слов и, если файл в порядке, текущий список слов заменяется списком из файла. Метод выглядит следующим образом:</p>
<pre class='examplecode'>
    /**
     * Попытка открыть файл XML со списком слов и провести его 
     * синтаксический анализ. В случае успеха список слов используется вместо 
     * текущего списка.
     * Адрес URL может указывать, например, на документ в локальной файловой системе, например 
     * &quot;file:///C:/testlist.xml&quot;, или на документ во всемирной сети Интернет,
     * например &quot;http://www.stanford.edu/~bsuter/simplewordlist.xml&quot;.
     *
     * @param url Адрес документа XML со списком слов.
     */
    protected void loadWordList(String url)
    {
	/* Создание экземпляра загрузчика */
	com.toy.anagrams.lib.WordListFileLoader wlfl = new com.toy.anagrams.lib.WordListFileLoader();

	/* Открытие и синтаксический анализ файла, замена текущего списка слов загруженным списком. */
	WordLibrary.setWordList(wlfl.loadList(url));

	/* Поскольку количество слов в новом списке может отличаться от предыдущего, 
	 * необходимо обновить значение wordIdx в соответствии с новым списком.
	 */
	wordIdx = new java.util.Random().nextInt(WordLibrary.getSize());
    }
</pre>
		<p>В игру вступает новый класс с именем WordListFileLoader. Кроме того, в классе WordLibrary появился новый метод setWordList. Метод добавлен на строке №125, он очень простой:</p>
<pre class='examplecode'>
    public static void setWordList(String[] wordList)
    {
	if ( wordList != null )
	    WORD_LIST = wordList;
    }
</pre>
		<p>Полный исходный код класса WordListFileLoader доступен <a href="https://netbeans.org/files/documents/4/307/WordListFileLoader.java">здесь</a>, однако остановимся на важнейших частях. В этом новом классе один существенный метод, а также внутренний класс-наследник org.xml.sax.helpers.DefaultHandler. Экземпляр WordListFileLoader предназначен для открытия, чтения, синтаксического анализа и оценки содержимого файла XML с локальной файловой системы или из документа XML, доступного по HTTP. Рассмотрим высокоуровневое описание работы метода WordListFileLoader.loadList:</p>
		<ul>
			<li>получение InputStream для указанного документа;</li>
			<li>создание синтаксического анализатора SAX (Simple API for XML) для этого документа;</li>
			<li>настройка обработчика, реагирующего на все события, поступающие от синтаксического анализатора SAX.</li>
		</ul>
		<p>Существует несколько способов синтаксического анализа документов XML средствами Java. Распространенный подход DOM (Document Object Model) связан с формированием в памяти иерархической модели множества узлов документа XML. В нашем случае структура набора данных проста (список слов), и проанализированный список немедленно конвертируется в массив String[], поэтому хранение документа XML в памяти не имеет большого смысла. Подход SAX основан на событиях: класс-обработчик ожидает события от синтаксического анализатора, которые возникают, когда синтаксический анализатор сталкивается с элементом XML, с атрибутом или с концом элемента. Обработчик может обрабатывать или игнорировать такие события. Если условия задачи этому способствуют, подход SAX предпочтителен, поскольку с его помощью можно обрабатывать очень объемные документы.</p>
<pre class='examplecode'>
   public String[] loadList(String url)
   {
	InputStream is;
	try {
		URL u = new URL(url);
		is = u.openConnection().getInputStream();
	} catch (IOException ioe) {
	    report(&quot;Не удалось открыть или найти указанный список слов.&quot;);
	    is = null;
	}

	if (is == null)
	{
	    report(&quot;Не удалось загрузить указанный список слов. Ошибка при открытии файла.&quot;);
	    return null;
	}

	SAXParserFactory parserFactory = SAXParserFactory.newInstance();
	SAXParser parser;
	try {
	  parser = parserFactory.newSAXParser();
	} catch ( ParserConfigurationException pce ) {
	    report(&quot;Ошибка при настройке синтаксического анализатора XML. Синтаксический анализатор не настроен надлежащим образом. Загрузка прекращена.&quot;);
	    return null;
	} catch ( SAXException saxe ) {
	    report(&quot;Ошибка при настройке синтаксического анализатора XML. Загрузка прекращена.&quot;);
	    return null;
	}

	try {
	    WordListHandler handler = new WordListHandler();
	    parser.parse(is, handler);
	} catch ( Exception e ) {
	    report(&quot;Не удалось загрузить список, вероятна ошибка синтаксического анализа SAX.&quot;);
	    return null;
	}

	return this.list;
    }
</pre>
		<p>Как указано выше, обработчик SAX должен реализовать различные обработчики событий, в нашем случае их ровно три: начало элемента, содержимое элемента и закрытие элемента. Итоговый код выглядит следующим образом:</p>
<pre class='examplecode'>
   public class WordListHandler extends DefaultHandler
   {
	protected String nodeType;
	protected ArrayList al;

	public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException
	{
	    if ( qName == &quot;word&quot; )
	    {
		nodeType = &quot;word&quot;;
	    } else if ( qName == &quot;wordlist&quot; ) {
	       al = new ArrayList();
	    }
	}

	public void endElement(String uri, String localName, String qName) throws SAXException
	{
	     if ( qName == &quot;word&quot; )
	     {
		 nodeType = null;
	     } else if (qName == &quot;wordlist&quot; ) {
		 /* ArrayList приводится к массиву объектов String. */
		 list = (String[]) this.al.toArray(new String[al.size()]);
	     }
	}

	public void characters(char[] chars, int start, int length) throws SAXException
	{
	    if ( this.nodeType == &quot;word&quot; )
	    {
		this.al.add(new String(chars, start, length).trim());
	    }
	}
    }
</pre>
		<p>В структуре документа со списком слов присутствуют элементы XML всего двух типов: &lt;word&gt; и &lt;wordlist&gt;. В приведенном коде видно, что фактическое добавление нового слова к списку выполняется с помощью метода characters. Остальные методы отслеживают обрабатываемый узел и выполняют действия по настройке и очистке, такие как инициализация нового списка слов и обновление поля списка внешнего класса.</p>
		<p>Полный исходный код Java для WordListFileLoader приведен <a href="https://netbeans.org/files/documents/4/307/WordListFileLoader.java">здесь</a>. Пример документа списка слов приведен <a href="https://netbeans.org/files/documents/4/305/simplelist.xml">здесь</a>; он также может выглядеть следующим образом:</p>
<pre class='examplecode'>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;wordlist&gt;
    &lt;word&gt;welcome&lt;/word&gt;
    &lt;word&gt;jacuzzi&lt;/word&gt;
    &lt;word&gt;elefant&lt;/word&gt;
    &lt;word&gt;abracadabra&lt;/word&gt;
&lt;/wordlist&gt;
</pre>
		<p>Итак, теперь можно создавать собственные списки слов путем создания и правки файлов XML в текстовом редакторе. Со временем, несомненно, можно придумать множество увлекательных тематических списков слов. Было бы здорово поделиться ими с широкой публикой? Еще было бы совершенно замечательно пользоваться списками слов, созданными другими людьми &mdash; такие слова было бы труднее угадать. Хорошая новость: в нашей программе это уже почти реализовано. Плохая новость: на этот раз автор воздержится от пошаговых указаний. Сначала необходимо создать новый пункт меню (например &quot;Download File List&quot; &mdash; загрузка списка файлов) аналогично созданной команде &quot;Open File List&quot;. Добавьте метод для связанного действия actionPerformed (как в прошлый раз) и используйте следующий код в качестве реализации метода:</p>
<pre class='examplecode'>
    private void downloadNewListMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
	String listURL;
	String prompt = &quot;Введите адрес URL списка слов в формате XML:&quot;;
	String initialValue = &quot;http://&quot;;

	listURL = (String) javax.swing.JOptionPane.showInputDialog(prompt, initialValue);

	/* Несложная проверка допустимости перед попыткой загрузки нового списка слов */
	if (listURL != null &amp;&amp; listURL.length() &gt; 0 &amp;&amp; listURL != initialValue)
	{
	    this.loadWordList(listURL);
	}
     }
</pre>
		<p>Более подробных сведений в этой статье приведено не будет, однако автор надеется, что удалось продемонстрировать эффективность и прямолинейность создания четких и правильных графических интерфейсов пользователя с помощью средства проектирования форм NetBeans. Разумеется, раскрыты только самые простые возможности, однако к приложению AnagramGame удалось добавить ценные функциональные возможности, и теперь в нашем распоряжении простая платформа, позволяющая опробовать новые концепции и глубже разобраться в NetBeans. Интереснее всего, разумеется, реализовать собственные идеи, однако рискнем предложить несколько для начала:</p>
		<ol>
			<li>Каждый список слов может быть снабжен необязательным атрибутом &quot;заголовок&quot;, который можно выводить в заголовке окна приложения.</li>
			<li>Если список слов не слишком велик, одно и то же слово может часто повторяться, делая игру более предсказуемой и менее интересной. Чтобы избежать этого эффекта, можно реализовать кэш недавно использованных слов. Для каждого следующего запроса слова можно было бы проверять, присутствует ли новое слово в кэше; если это так, можно запросить следующее слово, пока не будет получено слово, отсутствующее в кэше. Таким образом можно снизить число повторений. Для снижения частоты повторений с точки зрения пользователя размер кэша, вероятно, может быть достаточно небольшим, однако его размер всегда должен быть меньше, чем количество слов в списке, иначе можно получить бесконечный цикл.</li>
			<li>Можно создать другой загрузчик списка слов, принимающий любой текстовый документ. Такой загрузчик проводил бы синтаксический анализ всех строковых маркеров и создавал список слов, содержащий все уникальные слова. Возможно, стоит установить минимальную длину слова. Чтобы совсем усложнить игру, направьте этот загрузчик на иностранный новостной сайт!</li>
		</ol>


		<h2><a name="files">Список связанных файлов</a></h2>
			<table>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/306/anagrams.jar">anagrams.jar</a></td>
				<td>Измененное приложение AnagramGame в виде исполняемого файла JAR. Нажмите для игры!</td>
			</tr>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/305/simplelist.xml">simplelist.xml</a></td>
				<td>Пример списка слов в виде документа XML.</td>
			</tr>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/307/WordListFileLoader.java">WordListFileLoader.java &nbsp;</a></td>
				<td>Синтаксический анализатор списков слов в формате XML, основанный на SAX.</td>
			</tr>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/304/anagrams-src.zip">anagrams-src.zip</a></td>
				<td>Полный исходный код Java измененного приложения AnagramGame.</td>
			</tr>
		</table>

		<p></p>
	</body>
</html>
