<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-8">
	<TITLE>FeedReader</TITLE>
	
	<link rel="stylesheet" type="text/css" href="../../netbeans.css">
	<STYLE>
	<!--
		@page { size: 8.5in 11in }
		PRE { color: #808000 }
		P.boxnote { margin-left: 0.2in; margin-right: 0.2in; margin-top: 0.2in; margin-bottom: 0.2in; border: 1.00pt solid #9999cc; padding: 0.1in; color: #666699 }
		BLOCKQUOTE.western { font-style: italic }
	-->
	</STYLE>
</HEAD>
<BODY >
<H1>FeedReader</H1>
<b>Autor: Rich Unger</b>
<br><i>Este artigo foi submetido como parte do concurso Win With NetBeans. </i>
<p></p>
<H2 >Uma amostra de tutorial da plataforma NetBeans</H2>

<P><IMG SRC="../../images_www/articles/win-with-netbeans/feedreader-branded.jpg" NAME="Finished FeedReader" ALIGN=MIDDLE WIDTH=957 HEIGHT=714 BORDER=0>
</P>
<h2>O que faz o FeedReader?</h2>
<P>O FeedReader &eacute; um navegador b&aacute;sico de alimenta&ccedil;&atilde;o RSS/Atom, modelado com o plug-in <A HREF="https://addons.mozilla.org/de/firefox/addon/77/">Sage</A> para o Mozilla Firefox. Ele consiste em:</P>
<UL>
	<LI><P>Uma lista de alimenta&ccedil;&otilde;es (URLs para arquivos do descritor rss/rdf/atom)</P>
	<LI><P>Uma lista de manchetes de cada alimenta&ccedil;&atilde;o</P>
	<LI><P>Uma janela de navegador (mozilla incorporado em um JFrame)</P>
</UL>
<P>O mozzila frame incorporado &eacute; fornecido pela biblioteca <A HREF="https://jdic.dev.java.net/">JDIC</A>, que usa chamadas JNI. Eu configurei estes exemplo para usar as vers&otilde;es para o Linux e o Windows dos bin&aacute;rios JDIC </P>
<H3>A quem este tuturial est&aacute; dirigido?</H3>
<P>A audi&ecirc;ncia principal &eacute;, &eacute; claro, as pessoas que desejam desenvolver aplicativos na plataforma NetBeans. Irei tentar documentar por completo como criei o FeedReader, e o que cada linha no maifesto, arquivos de camadas e c&oacute;digo Java faz, especialmente nos casos onde tive que fazer algo ... um pouco rapidamente.</P>
<P>Esse &eacute; o motivo secund&aacute;rio para este tutorial. A rapidez e solu&ccedil;&otilde;es estranhas ser&atilde;o chamadas com uma &quot;Caixa Inesperada&quot;.</P>
<P CLASS="boxnote">Voc&ecirc; tem de fazer algo rapidamente para concluir isso.</P>
<P>Em tais casos, irei vincular com a quest&atilde;o em aberto apropriada no IssueZilla. Espero que este possa ser um documento que viva e que estas Caixas Inesperadas possam ser eliminadas ao longo do tempo, resultando em uma plataforma que seja mais f&aacute;cil para criar aplicativos.</P>
<h2>Primeiros passos</h2>
<P>O completo <A HREF="https://netbeans.org/files/documents/4/296/feedreader-source.zip">c&oacute;digo-fonte</A> est&aacute; dispon&iacute;vel.</P>
<P>Para os prop&oacute;sitos deste tutorial, n&atilde;o vou asuimir nenhum determinado IDE. De fato, vamos apenas dizer que voc&ecirc; tenha um editor de texto, JDK 1.5.0 (um bug na 1.4.x impede a compila&ccedil;&atilde;o desta amostra, mas ela ir&aacute; ser <i>executada</i> na 1.4.x), e o Apache Ant 1.6.2 ou posterior. Para simplificar os exemplos de linhas de comando, vou assumir bash (unix ou cygwin). Traduza para a linha de comando do Windows se desejar. Isso funciona bem, tamb&eacute;m.</P>
<P>S&oacute; n&atilde;o quero confund&iacute;-lo ao falar sobre o NetBeans <b>IDE</b> e a <b>plataforma</b> NetBeans. Siga primeiro este tutorial. Entenda como funciona o m&oacute;dulo. A seguir se preocupe com as ferramentas (como o Netbeans IDE) para desenvolv&ecirc;-los um pouco mais f&aacute;cil.</P>
<P>A primeira cosia que voc&ecirc; precisa para iniciar &eacute; uma c&oacute;pia da plataforma Netbeans. N&atilde;o &eacute; necess&aacute;rio desenvolv&ecirc;-lo a partir do c&oacute;digo-fonte. Basta baixar uma <A HREF="/downloads/">vers&atilde;o bin&aacute;ria</A> e efetuar o unzip para algum lugar. Coloquei o meu em <FONT FACE="Courier, monospace">home/rich/netbeans.</FONT></P>
<P>A seguir, seria de ajuda ter algum c&oacute;digo-fonte de amostra para ajudar-lhe a iniciar. Come&ccedil;ei o meu com <A HREF="http://contrib.netbeans.org/files/documents/130/269/cluster_build_harness.zip">cluster build harness</A>. Ele &eacute; conveniente porque j&aacute; tem scritps de desenvolvimento ant e m&oacute;dulos de empacotamento, e tem um m&oacute;dulo inicial denominado &quot;snipe&quot;. &Eacute; claro, agora que j&aacute; redigi isso, voc&ecirc; poderia iniciar facilmente seu aplicativo com a &aacute;rvore de c&oacute;digo-fonte para o FeedReader. 
</P>
<P>Eu efetuei o unzip de meu harness para <FONT FACE="Courier, monospace">/home/rich/src/rss.</FONT></P>
<P>Finalmente, voc&ecirc; precisa configurar seus scripts do build, para que saibam onde encontrar a instala&ccedil;&atilde;o da plataforma Netbeans:</P>
<P>Modifique algumas linhas em <FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/user.build.properties</FONT>:</P>
<PRE><FONT COLOR="#808000">netbeans.dest.dir=/home/rich/netbeans</FONT> <FONT COLOR="#808000">clustername=rssreader1</FONT></PRE><P>
Por conven&ccedil;&atilde;o, os clusters recebem um n&uacute;mero de vers&atilde;o no fim, embora isso n&atilde;o seja estritamente necess&aacute;rio.</P>
<BLOCKQUOTE CLASS="western">Defini&ccedil;&atilde;o: um <B>cluster</B> &eacute; um conjunto de m&oacute;dulos e arquivos de recursos associados. Uma instala&ccedil;&atilde;o NetBeans pode ser composta de um conjunto de clusters, que s&atilde;o selecionados quando voc&ecirc; inicia o NetBeans. O Netbeans, por exemplo, executa a plataforma4, ide-4, nb4.0 e clusters extras. A id&eacute;ia atr&aacute;s dos clusters, &eacute; a de que voc&ecirc; pode ter uma instala&ccedil;&atilde;o da plataforma Netbeans, e muitos aplicativos de marca compartilhando os mesmos clusters. Eu poderia, por exemplo, instalar o cluster rssreader1 en uma instala&ccedil;&atilde;o do Netbeans IDE e, ao aexcutar 2 scripts diferentes de inicializa&ccedil;&atilde;o, poderia obter o IDE e o FeedReader, cada um compartilhando o cluster platform4, mas sendo dois aplicativos completamente diferentes.</BLOCKQUOTE>
<P>A seguir, modifique algumas linhas em <FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/user.cluster.properties</FONT>, para trazer o nome do cluster em sincorniza&ccedil;&atilde;o com o que acabamos de especificar em <FONT FACE="Courier, monospace">user.build.properties</FONT>:</P>
<PRE>user.cluster=cluster.rssreader1
cluster.rssreader1.dir=rssreader1
cluster.rssreader1= snipe</PRE><P>
Agora, Eu poderia executar o <B><FONT FACE="Courier, monospace">ant</FONT></B> n o diret&oacute;rio <FONT FACE="Courier, monospace">nbbuild/</FONT>, e teria um diret&oacute;rio <FONT FACE="Courier, monospace">/home/rich/netbeans/rssreader1</FONT>, que cont&eacute;m o m&oacute;dulo snipe. &Eacute; claro que n&atilde;o queremos um m&oacute;dulo snipe, portanto, Eu digito <B><FONT FACE="Courier, monospace">ant clean</FONT></B>, para me livrar do mesmo.</P>
<P>Est&aacute; na hora de mover para o m&oacute;dulo que de fato desejamos.</P>
<h2>Biblioteca de m&oacute;dulos</h2>
<P>Voc&ecirc; poderia incorporar todo o aplicativo FeedReader em um &uacute;nico m&oacute;dulo. Isso n&atilde;o &eacute; muito ... bem ... modular. Acontece que o FeedReader requer as bibliotecas libraries JDOM, Rome e JDIC. Se em algum momento voc&ecirc; desejar estender este aplicativo com mais m&oacute;dulos que possam usar essas bibliotecas, seria melhor depender apenas do m&oacute;dulo de bibliotecas, ao inv&eacute;s de todo o FeedReader. Tamb&eacute;m, &eacute; poss&iacute;vel fazer com que os m&oacute;dulos de bibliotecas sejam auto-carregados.</P>
<BLOCKQUOTE CLASS="western">Defini&ccedil;&atilde;o: um m&oacute;dulo <B>autoload</B> &eacute; um m&oacute;dulo que ser&aacute; automaticamente carregado pelo NetBeans quando ele for necess&aacute;rio (por outro m&oacute;dulo). At&eacute; que isso aconte&ccedil;a, ele n&atilde;o utilizar&aacute; nenhuma mem&oacute;ria no tempo de execu&ccedil;&atilde;o.</BLOCKQUOTE>
<H4>Adicionando m&oacute;dulos &agrave; arvore de c&oacute;digo-fonte</H4>
<P>Sempre que voc&ecirc; adiciona um novo m&oacute;dulo, ser&aacute; preciso informar ao harness do build sobre isso. Modifique dois arquivos.</P>
<P><FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/user.cluster.properties:</FONT></P>
<PRE>cluster.rssreader1=snipe, \
                   anothermodule, \
                   yetanother</PRE><P>
Isso informa aos scripts do build quais m&oacute;dulos est&atilde;o em seu cluster, para que saibam como desenvolver todo o cluster como uma unidade e, em qual diret&oacute;rio instalar os arquivos jar resultantes.</P>
<P><FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/modules.xml:</FONT></P>
<PRE>&lt;module&gt;
  &lt;path&gt;snipe&lt;/path&gt;
  &lt;cnb&gt;org.netbeans.modules.snipe&lt;/cnb&gt;
&lt;/module&gt;</PRE><P>
Isso mapeia o nome do diret&oacute;rio contendo o c&oacute;digo-fonte do m&oacute;dulo, e com o nome o Netbeans saber&aacute; sobre isso no tempo de execu&ccedil;&atilde;o (&quot;crb&quot; significa base do nome do c&oacute;digo).</P>
<H4>JDOM</H4>
<P>Assumo que a maioria dos leitores saibam o que &eacute; JDOM. &Eacute; uma API de an&aacute;lise XML e, a &uacute;nica raz&atilde;o pela qual o FeedReader precisa dela &eacute; a de que a biblioteca Rome usa a mesma.</P>
<P>Come&ccedil;e por adicionar &quot;jodom&quot; &agrave; lista de clusters e 
</P>
<PRE>&lt;module&gt;
  &lt;path&gt;jdom&lt;/path&gt;
  &lt;cnb&gt;org.jdom.api&lt;/cnb&gt;
&lt;/module&gt;</PRE><P>
&agrave; lista de m&oacute;dulos. Agora, aqui est&aacute; a lista do m&oacute;dulo JDOM: </P>
<PRE>build.xml
manifest.mf
nbproject/project.xml
nbproject/project.properties
lib/jdom.jar
src/org/jdom/api/Bundle.properties</PRE><P>
Vamos examinar estes um de cada vez.</P>
<P><B>build.xml</B>: o arquivo build come&ccedil;a por importar outro arquivo build denominado projectized.xml. Na maioria das vezes, isso &eacute; tudo que voc&ecirc; precisa para t&ecirc;-lo em seu arquivo build do m&oacute;dulo. No entanto, no m&oacute;dulo JDOM, voc&ecirc; deseja incluir jdom,jar no pacote do m&oacute;dulo, al&eacute;m do pr&oacute;prio jar do m&oacute;dulo. </P>
<P CLASS="boxnote">Inesperado n&ordm; 1: Voc&ecirc; n&atilde;o precisaria sobrepor o comportamento do build para poder incluir bibliotecas adicionais. Voc&ecirc; deveria ser capaz de declarar tais depend&ecirc;ncias no arquivo project.xml e os scripts do build deveriam saber como criar as entradas apropriadas do manifesto e incluir as mesmas no arquivo nbm.
<BR><BR><A HREF="https://netbeans.org/bugzilla/show_bug.cgi?id=52354">https://netbeans.org/bugzilla/show_bug.cgi?id=52354</A></P>
<P>Portanto, sobreponha 2 alvos. O alvo “files-init” &eacute; uma c&oacute;pia exata do alvo do projectized.xml, com uma linha adicional:</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;include name=&quot;${nb.modules.dir}/ext/jdom.jar&quot;/&gt;</PRE><P>
O alvo “files-init” permite que o script do build saiba quais arquivos pertencem ao m&oacute;dulo. Estes s&atilde;o arquivos que s&atilde;o exclu&iacute;dos quando voc&ecirc; executa o alvo &quot;clean&quot;. &Eacute; uma conven&ccedil;&atilde;o o fato de quais jars que n&atilde;o est&aacute; nos m&oacute;dulos v&atilde;o para o diret&oacute;rio<FONT FACE="Courier, monospace">ext/</FONT>.
<p>O outro alvo que precisa ser sobreposto &eacute; o “netbeans-extra”. Isso &eacute; um gancho fornecido pelos scripts do build para fornecer-lhe um local para fazer coisas como copiar arquivos como parte do processo de implementa&ccedil;&atilde;o.</P>
<PRE>&lt;target name=&quot;netbeans-extra&quot; depends=&quot;init&quot;&gt;
    &lt;mkdir dir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/ext&quot;/&gt;
    &lt;copy todir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/ext&quot;&gt;
      &lt;fileset dir=&quot;lib&quot;&gt;
        &lt;include name=&quot;jdom.jar&quot;/&gt;
      &lt;/fileset&gt;
    &lt;/copy&gt;
&lt;/target&gt;</PRE><P>
Isso copia o arquivo jdom.jar para <FONT FACE="Courier, monospace">/home/rich/netbeans/rssreader1/modules/ext.</FONT></P>
<P><FONT FACE="Times New Roman"><B>manifest.mf</B>: Cada arquivo jar precisa de um manifesto. Um m&oacute;dulo do NetBeans &eacute; simplesmente um arquivo jar, cujo manifesto cont&eacute;m ao menos duas linhas:</FONT></P>
<PRE>OpenIDE-Module: org.jdom.api/1
OpenIDE-Module-Specification-Version: 1.0</PRE><P>
A primeira linha &eacute; apenas o nome do m&oacute;dulo e, opcionalmente, um <I>n&uacute;mero de vers&atilde;o</I>. Observe que o nome coincide com o &lt;cnb&gt; (base do nome do c&oacute;dio) do arquivo modules.xml.</P>
<P STYLE="font-style: normal">A segunda linha &eacute; a <I>especifica&ccedil;&atilde;o da vers&atilde;o</I> do m&oacute;dulo..</P>
<BLOCKQUOTE CLASS="western">Um palavra sobre n&uacute;meros de vers&atilde;o... Um m&oacute;dulo pode ter 3 n&uacute;meros diferentes de vers&atilde;o: um <B>n&uacute;mero de vers&atilde;o</B>, uma <B>especifica&ccedil;&atilde;o da vers&atilde;o</B> e uma <B>vers&atilde;o de implementa&ccedil;&atilde;o</B>. 
</BLOCKQUOTE>
<BLOCKQUOTE CLASS="western">Vamos dizer, por exemplo, que o m&oacute;dulo A tem um n&uacute;mero de vers&atilde;o 1, uma especifica&ccedil;&atilde;o de vers&atilde;o 2.0 e uma vers&atilde;o de implementa&ccedil;&atilde;o beta3. Agora, o m&oacute;dulo B ir&aacute; declarar uma depend&ecirc;ncia no m&oacute;dulo A (em seu arquivo project.xml). Ele <SPAN STYLE="text-decoration: none"><SPAN STYLE="font-style: normal">precisa </SPAN>especificar um n&uacute;mero de vers&atilde;o de 1. Ele <SPAN STYLE="font-style: normal">pode opcionalmente</SPAN> especificar uma depend&ecirc;ncia da especifica&ccedil;&atilde;o de vers&atilde;o 2.0. Caso n&atilde;o o fa&ccedil;a, e o autor de A libera uma vers&atilde;o 2.1, isso &eacute; OK, a depend&ecirc;ncia ainda ir&aacute; funcionar. O contrato &eacute; que as classes API p&uacute;blicas expostas pelo m&oacute;dulo A (consulte o elemento &lt;public-packages&gt; do project.xml) n&atilde;o ir&aacute; quebrar a compatibilidade. Uma depend&ecirc;ncia na especifica&ccedil;&atilde;o da vers&atilde;o somente fornece ao B o acesso a estas classes de API. </SPAN>
</BLOCKQUOTE>
<BLOCKQUOTE CLASS="western" STYLE="text-decoration: none"><I>Se o m&oacute;dulo B especifica uma depend&ecirc;ncia da vers&atilde;o de implementa&ccedil;&atilde;o beta3, somente ir&aacute; funcionar com aquela vers&atilde;o do m&oacute;dulo A. Ne entanto, ele ter&aacute; acesso &agrave; todas as classes p&uacute;blicas no m&oacute;dulo A. (Se voc&ecirc; estiver recebendo uma NoClassDefFoundException ao executar seu m&oacute;dulo, poderia ser porque voc&ecirc; est&aacute; tentando acessar classes n&atilde;o-API sem especificar uma depend&ecirc;ncia de implementa&ccedil;&atilde;o)</I>.</BLOCKQUOTE>
<P>Somente mais 2 linhas no manifesto:</P>
<PRE>OpenIDE-Module-Localizing-Bundle: org/jdom/api/Bundle.properties
Class-Path: ext/jdom.jar</PRE><P>
A primeira linha &eacute; totalmente opcional. Ela aponta para um conjunto contendo mais entradas do manifesto. Essas entradas do manifesto s&atilde;o sequ&ecirc;ncias de caracteres localiz&aacute;veis, tais como o nome e descri&ccedil;&atilde;o para este m&oacute;dulo.</P>
<P>A segunda linha &eacute; a entrada do manifesto Class-Path padr&atilde;o, que coloca o arquivo jdom.jar na classpath do arquivo jar do m&oacute;dulo. Observe que o caminho “ext/jdom.jar” coincide com onde voc&ecirc; copiou o jdom.jar no arquivo build.xml.</P>
<P CLASS="boxnote">Inesperado n&ordm; 2: N&atilde;o deveria ser preciso especificar a Class-Path. Ela deveria ser gerada automaticamente (consulte Inesperado n&ordm; 1).</P>
<P><B>nbproject/project.xml</B>: Este &eacute; o arquivo que informa aos scripts do build (e ao IDE se o estiver usando) como gerar as declara&ccedil;&otilde;es de depend&ecirc;ncias e as classpaths. Aqui tamb&eacute;m &eacute; preciso especificar a informa&ccedil;&atilde;o familiar &lt;base de nome do c&oacute;digo&gt; e &lt;caminho&gt;. A seguir, &eacute; preciso especificar quaisquer depend&ecirc;ncias sobre outros m&oacute;dulos. Agora, vendo que n&atilde;o h&aacute; c&oacute;digo real no pr&oacute;rprio m&oacute;dulo, e um jdom.jar n&atilde;o requer qualquer outro c&oacute;digo fora das classes JRE, n&atilde;o h&aacute; realmente nenhuma depend&ecirc;ncia de m&oacute;dulo a ser declarada. Ainda assim, voc&ecirc; deveria sempre declarar uma depend&ecirc;ncia nas classes OpenAPI n&uacute;cleo:</P>
<PRE>&lt;dependency&gt;
  &lt;code-name-base&gt;org.openide&lt;/code-name-base&gt;
    &lt;build-prerequisite/&gt;
    &lt;compile-dependency/&gt;
    &lt;run-dependency&gt;
      &lt;release-version&gt;1&lt;/release-version&gt;
      &lt;specification-version&gt;4.5&lt;/specification-version&gt;
  &lt;/run-dependency&gt;
&lt;/dependency&gt;</PRE><P>
Esse &eacute; um tipo de caso especial. Caso voc&ecirc; n&atilde;o especifica isso, com uma especifica&ccedil;&atilde;o de vers&atilde;o recente, o NetBeans ir&aacute; assumir que este &eacute; um m&oacute;dulo antigo e, automaticamente, ir&aacute; carregar diversas depend&ecirc;ncias no momento do tempo de execu&ccedil;&atilde;o, para fins de compatibilidade retroativa.</P>
<P>A seguir, &eacute; preciso declarar os <FONT FACE="Courier, monospace">&lt;pacotes p&uacute;blicos&gt;</FONT> do m&oacute;dulo. Isso serve para dois prop&oacute;sitos: os pacotes p&uacute;blicos s&atilde;o vis&iacute;veis para outros m&oacute;dulos que declaram depend&ecirc;ncia com este m&oacute;dulo e, eles constituem um conjunto de pacotes que ter&atilde;o javadocs gerados ao executar o alvo ant &quot;javadoc&quot;.</P>
<P>Voc&ecirc; pode especificar cada pacote individualmente:</P>
<PRE>&lt;public-packages&gt;
  &lt;package&gt;org.jdom&lt;/package&gt;
  &lt;package&gt;org.jdom.adapters&lt;/package&gt;
  &lt;package&gt;org.jdom.input&lt;/package&gt;
  ...
&lt;/public-packages&gt;</PRE><P>
Ou pode obter toda a &aacute;rvore com uma linha:</P>
<PRE>&lt;public-packages&gt;
  &lt;subpackages&gt;org.jdom&lt;/subpackages&gt;
&lt;/public-packages&gt;</PRE><P>
No entanto, esse m&eacute;todo n&atilde;o funciona com o alvo &quot;javadoc&quot;.</P>
<P><B>project.properties</B>: Algumas dicas adicionais para o processo do build...</P>
<PRE>is.autoload=true
cp.extra=lib/jdom.jar
module.javadoc.packages=org.jdom</PRE><P>
A primeira linha torna este um m&oacute;dulo <I>autoload</I>. A segunda linha &eacute; anexada na classpath de compila&ccedil;&atilde;o. A terceira linha &eacute; necess&aacute;rio se voc&ecirc; uso o m&eacute;todo <FONT FACE="Courier, monospace">&lt;subpackages&gt;</FONT> para declarar seus <FONT FACE="Courier, monospace">&lt;pacotes p&uacute;blicos&gt;</FONT> no project.xml.</P>
<P CLASS="boxnote">Inesperado n&ordm; 3: N&atilde;o deveria ser necess&aacute;rio especificar aqui o module.javadoc.packages. Os scripts do build deveriam ter uma retirada s&atilde;, com a suposi&ccedil;&atilde;o de que o usu&aacute;rio n&atilde;o est&aacute; interessado em javadocs para este m&oacute;dulo. Neste momento, o build falha se isso n&atilde;o for especificado.<BR><BR><A HREF="https://netbeans.org/bugzilla/show_bug.cgi?id=52135">https://netbeans.org/bugzilla/show_bug.cgi?id=52135</A>
<br><br>* Atualiza&ccedil;&atilde;o: Corrigido para o NetBeans 4.1</P>
<h3 class='tutorial'>Rome</h3>
<H3>Rome</H3>
<P>A biblioteca <A HREF="https://rome.dev.java.net/">Rome</A> l&ecirc; alimenta&ccedil;&otilde;es RSS e Atom (com uma API muito simples, posso afirmar). O m&oacute;dulo Rome e o m&oacute;dulo JDOM s&atilde;o diferentes em apenas dois aspectos. O m&oacute;dulo Rome incorpora dois arquivos jar (rome-0.4.jar e rome-fetcher-0.4.jar) ao inv&eacute;s de um, e o project.xml declara uma depened&ecirc;ncia do m&oacute;dulo JDOM:</P>
<PRE>&lt;dependency&gt;
  &lt;code-name-base&gt;org.jdom.api&lt;/code-name-base&gt;
  &lt;build-prerequisite/&gt;
  &lt;compile-dependency/&gt;
  &lt;run-dependency&gt;
    &lt;release-version&gt;1&lt;/release-version&gt;
    &lt;specification-version&gt;1.0&lt;/specification-version&gt;
  &lt;/run-dependency&gt;
&lt;/dependency&gt;</PRE><H3>
JDIC</H3>
<P>A biblioteca <A HREF="https://jdic.dev.java.net/">JDIC</A> permite que os programas Java tirem vantagem de determinadas facilidades nativas, tal como navegadores, correios, bandejas do sistema e registros do tipo MIME. O FeedReader usa o componente de navegador nativo incorporado para produzir p&aacute;ginas da Web em um JFrame com o mecanismo de renderiza&ccedil;&atilde;o IE ou Mozilla.</P>
<P>Para poder realizar isso, a JDIC cria chamadas Java Native Interface (JNI) para esta biblioteca compartilhada (<FONT FACE="Courier, monospace">jdic.dll</FONT> ou <FONT FACE="Courier, monospace">libjdic.so</FONT>), assim como executa execut&aacute;veis nativos (<FONT FACE="Courier, monospace">IeEmbed.exe</FONT> ou <FONT FACE="Courier, monospace">mozembed-linux-gtk2</FONT>). Voc&ecirc; precisa fazer uma pequena m&aacute;gica no arquivo build do m&oacute;dulo para tornar essas bibliotecas e execut&aacute;veis dispon&iacute;veis para o NetBeans no momento da execu&ccedil;&atilde;o.</P>
<P>Observe o conjunto de arquivos declarados na tarefa &quot;files-init&quot;:</P>
<PRE>&lt;include name=&quot;${nb.modules.dir}/ext/jdic.jar&quot;/&gt;
&lt;include name=&quot;lib/libjdic.so&quot;/&gt;
&lt;include name=&quot;lib/libmozembed-linux-gtk1.2.so&quot;/&gt;
&lt;include name=&quot;lib/libmozembed-linux-gtk2.so&quot;/&gt;
&lt;include name=&quot;lib/mozembed-linux-gtk1.2&quot;/&gt;
&lt;include name=&quot;lib/mozembed-linux-gtk2&quot;/&gt;
&lt;include name=&quot;lib/jdic.dll&quot;/&gt;
&lt;include name=&quot;lib/IeEmbed.exe&quot;/&gt;
&lt;include name=&quot;lib/nspr4.dll&quot;/&gt;
&lt;include name=&quot;bin/${shell.script}&quot;/&gt;
&lt;include name=&quot;bin/${batch.script}&quot;/&gt;</PRE><P>
Al&eacute;m da declara&ccedil;&atilde;o de arquivo jar familiar, h&aacute; uma lista de bibliotecas nativas e execut&aacute;veis em <FONT FACE="Courier, monospace">lib/</FONT> e um par de scripts. A decis&atilde;o de colocar a coisa nativa neste determinado diret&oacute;rio &eacute; um pouco arbitr&aacute;ria, embora seja a localiza&ccedil;&atilde;o sugerida na <A HREF="http://openide.netbeans.org/proposals/arch/installation.html#logical">documenta&ccedil;&atilde;o de arquitetura</A>. A &uacute;nica outra coisa que precisa conhecer esta localiza&ccedil;&atilde;o &eacute; o script de inicializa&ccedil;&atilde;o.</P>
<P>O script shell e o script batch s&atilde;o gerados pelo alvo <FONT FACE="Courier, monospace">shellscript</FONT> do arquivo build. Estes scripts inicializam a plataforma NetBeans com o cluster rssreader1 e os bin&aacute;rios jdic em seus caminhos corretos.</P>
<h2>M&oacute;dulo FeedReader </h2>
<P>Agora que voc&ecirc; tem todos os m&oacute;dulos de bibliotecas necess&aacute;rios, est&aacute; pronto para criar um m&oacute;dulo que de fato <I>faz</I> algo.</P>
<P STYLE="font-style: normal">Come&ccedil;e por criar os scripts do build e os elementos declarativos do m&oacute;dulo. O arquivo <FONT FACE="Courier, monospace">build.xml</FONT> est&aacute; bem vazio, com exce&ccedil;&atilde;o da linha de importa&ccedil;&atilde;o para o “projectized.xml” padr&atilde;o. O arquivo <FONT FACE="Courier, monospace">nbproject/project.xml</FONT> somente declara as depend&ecirc;ncias de seus 3 m&oacute;dulos de biblioteca e n&atilde;o tem pacotes p&uacute;blicos (este m&oacute;dulo n&atilde;o fornece nenhuma API para outros m&oacute;dulos). O arquivo <FONT FACE="Courier, monospace">nbproject/project.properties</FONT> tamb&eacute;m est&aacute; vazio. O arquivo <FONT FACE="Courier, monospace">manifest.mf </FONT> deveria parecer bem familiar tamb&eacute;m. H&aacute; apenas um novo elemento no mesmo:</P>
<PRE STYLE="margin-bottom: 0.2in">OpenIDE-Module-Layer: org/netbeans/modules/feedreader/resources/layer.xml</PRE><P>
Diferente dos m&oacute;dulos de bibliotecas, voc&ecirc; ir&aacute; declarar coisas sobre a interface do usu&aacute;rio do FeedReader em um arquivo de camadas, para inclus&atilde;o no “system filesystem.”</P>
<BLOCKQUOTE CLASS="western">Defini&ccedil;&atilde;o: O <B>system filesystem</B> &eacute; onde o NetBeans armazena todas as configura&ccedil;&otilde;es do sistema, informa&ccedil;&otilde;es do layout IGU, a&ccedil;&otilde;es, modelos e, todo o necess&aacute;rio para manter o estado da instala&ccedil;&atilde;o do NetBeans. Isso &eacute; composto de arquivos reais localizados no diret&oacute;rio &quot;config&quot; de cada cluster, o diret&oacute;rio &quot;config&quot; do diret&oacute;rio do usu&aacute;rio NetBeans, e os &quot;arquivos&quot; virtuais declarados nos arquivos de camadas do m&oacute;dulo.
</BLOCKQUOTE>
<h3 class='tutorial'>Arquivo de camadas</h3>
<P>A primeira entrada est&aacute; na pasta de n&iacute;vel superior denominada <FONT FACE="Courier, monospace">Actions</FONT>. Este &eacute; um reposit&oacute;rio para as implementa&ccedil;&otilde;es do <FONT FACE="Courier, monospace">javax.swing.Action</FONT>. Ele podem ser usados para itens de menus, bot&otilde;es da barra de ferramentas e atalhos de teclado. Adicionar esta entrada ir&aacute; permitir aos usu&aacute;rios a atribuir atalhos de teclado para o ViewFeedsAction ao selecionar &quot;Ferramentas ... Atalhos de teclado&quot; no menu.</P>
<P>A segunda entrada coloca o ViewFeedsAction sob o menu &quot;Visualizar&quot;. Observe a sintaxe do arquivo shadow, o que o mesmo que usar um link no UNIX ou um talho no Windows.</P>
<P>O restante da entrada fica sob a pasta de n&iacute;vel superior <FONT FACE="Courier, monospace">Windows2</FONT>. Esta pasta fornece informa&ccedil;&otilde;es para a plataforma sobre quais tipos de <A HREF="https://netbeans.org/download/4_0/javadoc/OpenAPIs/org/openide/windows/doc-files/api.html#overview-top">TopComponent</A> ser&atilde;o instanciados e onde coloc&aacute;-los. (Incidentalmente, isso &eacute; chamado de “Windows2” porque o “Windows” &eacute; o antigo sistema Windows 3.6, que n&oacute;s mantivemos por quest&otilde;es de compatibilidade retroativa). O FeedReader cont&eacute;m duas defini&ccedil;&otilde;es TopComponent: SiteListComponent e EntryListComponent. O segundo deve ser aberto na localiza&ccedil;&atilde;o padr&atilde;o (o centro), portanto, nada &eacute; necess&aacute;rio no arquivo de camadas para sobrepor este comportamento.</P>
<P>O <FONT FACE="Courier, monospace">SiteListComponent</FONT>, no entanto, deve ser deixado no lado esquerdo ou o modo &quot;explorer&quot;. Portanto, adicione uma entrada:</P>
<PRE>&lt;folder name=&quot;Modes&quot;&gt;
    &lt;folder name=&quot;explorer&quot;&gt;            
        &lt;file name=&quot;rss_list.wstcref&quot; url=&quot;feedList.wstcref&quot;/&gt;
    &lt;/folder&gt;
&lt;/folder&gt;</PRE><P>
Isso declara que uma <FONT FACE="Courier, monospace">TopComponent</FONT> com a ID “rss_list” ser&aacute; estacionada, por padr&atilde;o, no modo &quot;explorer&quot;. (Incidentalmente, a extens&atilde;o “wstcref” significa <I>Window System Top Component REFerence</I>.) A coloca&ccedil;&atilde;o desta “rss_list” dentro do modo declarado &eacute; derivada do arquivo <FONT FACE="Courier, monospace">feedList.wstcref</FONT>:</P>
<PRE>&lt;tc-ref version=&quot;2.0&quot;&gt;
    &lt;module name=&quot;org.netbeans.modules.feedreader/1&quot; spec=&quot;1.0&quot; /&gt;
    &lt;tc-id id=&quot;rss_list&quot; /&gt;
    &lt;state opened=&quot;true&quot; /&gt;
&lt;/tc-ref&gt;</PRE><P>
o valor de <FONT FACE="Courier, monospace">&lt;tc-id id&gt;</FONT> precisa coincidir com o nome base do arquivo declarado na camada (“rss_list”). O mesmo nome tamb&eacute;m precisa estar presente na pasta <FONT FACE="Courier, monospace">Windows2/Components</FONT> com uma extens&atilde;o “.settings”:</P>
<PRE>&lt;folder name=&quot;Components&quot;&gt;
    &lt;file name=&quot;rss_list.settings&quot; url=&quot;feedList.settings&quot; /&gt;
&lt;/folder&gt;</PRE><P>
O conte&uacute;do do arquivo de configura&ccedil;&otilde;es informa ao NetBeans como instanciar uma “rss_list”. Voc&ecirc; pode redigir o conte&uacute;do deste arquivo a m&atilde;o, ou pode atrav&eacute;s de coment&aacute;rio retirar toda a se&ccedil;&atilde;o Windows2 deste arquivo de camadas, iniciar o Netbeans, instanciar um <FONT FACE="Courier, monospace">SiteListComponent</FONT> ao executar a <FONT FACE="Courier, monospace">ViewFeedsAction</FONT>, e pegar o arquivo de configura&ccedil;&otilde;es que &eacute; auto-gerado no <FONT FACE="Courier, monospace">$userdir/config/Windows2Local/Component</FONT>. A seguir, substitua a se&ccedil;&atilde;o <FONT FACE="Courier, monospace">&lt;serialdata&gt;</FONT> por:</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;instance class=&quot;org.netbeans.modules.feedreader.SiteListComponent&quot;/&gt;</PRE><P>
Isso cria o componente usando o construtor padr&atilde;o do <FONT FACE="Courier, monospace">SiteListComponent</FONT>. Se a classe requerida for um m&eacute;todo de f&aacute;brica est&aacute;tica, voc&ecirc; poderia adicionar um atributo de m&eacute;todo:</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;instance class=&quot;org.netbeans.modules.feedreader.SiteListComponent&quot; method=”makeSiteListComponent”/&gt;</PRE><H4>
ViewFeedsAction.java</H4>
<P>Agora tudo que resta fazer &eacute; o c&oacute;digo Java real. A primeira classe declarada no arquivo de camadas &eacute; a <FONT FACE="Courier, monospace">ViewFeedsAction.java</FONT>. Esta &eacute; uma subclasse simples da <FONT FACE="Courier, monospace">CallableSystemAction</FONT>, que &eacute; uma implementa&ccedil;&atilde;o singleton da <FONT FACE="Courier, monospace">javax.swing.Action</FONT>.</P>
<PRE>    public void performAction() {
        SiteListComponent.activate();
    }</PRE><P>
A execu&ccedil;&atilde;o desta a&ccedil;&atilde;o ir&aacute; abrir e oferecer o foco &agrave; inst&acirc;ncia singleton da SiteListComponent (consulte abaixo a implementa&ccedil;&atilde;o do SiteListComponent).</P>
<PRE>    public String getName() {
        return NbBundle.getMessage(SiteListComponent.class, &quot;SLC_title&quot;);
    }</PRE><P>
O nome da a&ccedil;&atilde;o &eacute; armazenado em Bundle.properties, para que possa ser localizado.</P>
<PRE>    public HelpCtx getHelpCtx() {
        return HelpCtx.DEFAULT_HELP;
    }</PRE><P>
Voc&ecirc; iria alterar isso se tivesse uma ID JavaHelp id ou um URL com ajuda mais espec&iacute;fica para esta a&ccedil;&atilde;o.</P>
<PRE>    protected boolean asynchronous() {
        return false;
    }</PRE><P>
Consulte a <A HREF="https://netbeans.org/download/4_0/javadoc/OpenAPIs/org/openide/util/actions/CallableSystemAction.html#asynchronous()">entrada javadoc</A> para obter mais detalhes.</P>
<h3 class='tutorial'>SiteListComponent.java</h3>
<P CLASS="boxnote">Inesperado n&ordm; 4: Um dos c&oacute;digos mais confusos nesta classe (o que trata das IDs), tem a ver em assegurar uma inst&acirc;ncia singleton do SiteListComponent, com a ID especificada no arquivo de camadas. Idealmente, deveria haver uma subclasse do TopComponent denominada como algo como SingletonTopComponent, j&aacute; que isso parece ser algo que voc&ecirc; deseja fazer.<BR><BR><A HREF="https://netbeans.org/bugzilla/show_bug.cgi?id=53252">https://netbeans.org/bugzilla/show_bug.cgi?id=53252</A></P>
<P>O c&oacute;digo a seguir assegura um singleton:</P>
<PRE>    /** A hint to the window system for generating a unique id */
    private static final String PREFERRED_ID = &quot;rss_list&quot;; // NOI18N
    
    /** The actual id of the (singleton) instance */
    private static String s_id = PREFERRED_ID;

    ...

    public static synchronized SiteListComponent getInstance()
    {
        TopComponent c;
        c = WindowManager.getDefault().findTopComponent(s_id);
        if (c == null)
        {
            c = new SiteListComponent();
            s_id = WindowManager.getDefault().findTopComponentID(c);
        }
        return (SiteListComponent)c;
    }

    ...

    protected String preferredID() { 
        return PREFERRED_ID;
    }</PRE><P>
O NetBeans mant&eacute;m um mapa de todos os <FONT FACE="Courier, monospace">TopComponent</FONT>s no momento na mem&oacute;ria. A chave para este mapa &eacute; o que Eu me refiro como a “ID”. A ID &quot;preferida&quot; &eacute; apenas uma dica para o sistema Windows, a ser usada ao criar a nova inst&acirc;ncia. N&atilde;o h&aacute; uma <I>garantia</I> de que essa dica fa&ccedil;a algo. &Eacute; normalmente &uacute;til para que voc&ecirc; possa reconhecer o nome do componente se estiver rastreando problemas ao examinar o conte&uacute;do de <FONT FACE="Courier, monospace">$userdir/config/Windows2Local</FONT>.</P>
<P STYLE="font-style: normal">O campo est&aacute;tico <FONT FACE="Courier, monospace">s_id</FONT>, no entanto, &eacute; para ser a ID de uma inst&acirc;ncia do <FONT FACE="Courier, monospace">SiteListComponent</FONT> na mem&oacute;ria. Ele padroniza para “rss_list” porque este &eacute; o valor da ID fornecida em <FONT FACE="Courier, monospace">feedList.wstcref</FONT>. Portanto, se esta for a primeira vez que o usu&aacute;rio utiliza este m&oacute;dulo, o componente com a ID “rss_list” ser&aacute; instanciado de forma declarat&oacute;ria. No entanto, se o usu&aacute;rio fecha aquele componente, reinicia o NetBeans, e depois chama o <FONT FACE="Courier, monospace">ViewFeedsAction</FONT>, o novo componente poder&aacute; ter uma ID diferente. Por isso o m&eacute;todo getInstance() pode atribuir um novo valor para s_id.</P>
<P STYLE="font-style: normal">Se a ID n&atilde;o muda, n&atilde;o h&aacute; nada no arquivo de camadas para insistir que o componente seja estacionado no modo &quot;explorer&quot;. Para for&ccedil;ar isso, sobreponha o m&eacute;todo open():</P>
<PRE>    private static final String MODE = &quot;explorer&quot;; // NOI18N

    public void open()
    {
        Mode m = WindowManager.getDefault().findMode(MODE);
        m.dockInto(this);
        super.open();
    }</PRE><P>
O resto nesta classe n&atilde;o &eacute; espec&iacute;fico do NetBeans. O componente consiste em uma JList e dois bot&otilde;es: uma para adicionar uma nova alimenta&ccedil;&atilde;o e um para excluir uma alimenta&ccedil;&atilde;o selecionada. A lista &eacute; suportadoa por uma SiteListModel.</P>
<h3 class='tutorial'>SiteListModel</h3>
<P>A classe <FONT FACE="Courier, monospace">SiteListModel</FONT> adiciona somente a serializa&ccedil;&atilde;o ao swing <FONT FACE="Courier, monospace">DefaultListModel</FONT>. Na constru&ccedil;&atilde;o, ele carrega a lista de alimenta&ccedil;&otilde;es do disco. Ela atualiza a lista no disco com cada edi&ccedil;&atilde;o da lista. (Excesso? Talvez, mas n&atilde;o ser&aacute; uma lista longa, e ap&oacute;s o usu&aacute;rio a configurar, as edi&ccedil;&otilde;es n&atilde;o ser&atilde;o fequentes).</P>
<P>A parte importante &eacute; a de decidir <I>onde</I> serializar a lista. Ao coloc&aacute;-la no system filesystem, voc&ecirc; pode fazer com que o arquivo serializado fa&ccedil;a parte da estrutura em <FONT FACE="Courier, monospace">$userdir/config</FONT>:</P>
<PRE>    private static final String DIR = &quot;FeedReader&quot;; //NOI18N
    private static final String FILENAME = &quot;feeds.ser&quot;; //NOI18N

    private FileObject getSerializedFile(boolean create) throws IOException
    {
        FileSystem sysFs = Repository.getDefault().getDefaultFileSystem();
        FileObject dir = sysFs.findResource(DIR);
        if (dir == null)
        {
            if (create)
                dir = sysFs.getRoot().createFolder(DIR);
            else
                return null;
        }
        
        FileObject fo = dir.getFileObject(FILENAME);
        if (fo == null)
        {
            if (create)
                fo = dir.createData(FILENAME);
            else
                return null;
        }
        
        return fo;
    }</PRE><P>
O par&acirc;metro booleano <FONT FACE="Courier, monospace">create</FONT>, ir&aacute; determinar onde voc&ecirc; deseja criar o arquivo, caso j&aacute; n&atilde;o l&aacute; esteja (verdadeiro para grava&ccedil;&atilde;o e falso para leitura).</P>
<P>Portanto, a lista serializada acabar&aacute; em <FONT FACE="Courier, monospace">$userdir/config/FeedReader/feeds.ser</FONT>.</P>
<P>Esta &eacute; uma abordagem de baixo n&iacute;vel para gravar a lista de alimenta&ccedil;&otilde;es. H&aacute; de fato, uma API do NetBeans que cuisa disso para voc&ecirc;. Voc&ecirc; poderia implementar a serializa&ccedil;&atilde;o ao definir a subclasse <FONT FACE="Courier, monospace">SystemOption</FONT>, e apenas sobrepor<FONT FACE="Courier, monospace">readExternal()</FONT> e <FONT FACE="Courier, monospace">writeExternal()</FONT>. Eu escolho gravar direto no system filesystem para dar-lhe uma melhor id&eacute;ia do que est&aacute; acontecendo por tr&aacute;s dos panos. Tamb&eacute;m, esta implementa&ccedil;&atilde;o lhe d&aacute; maior flexibilidade para usar outro formato de arquivo. Ap&oacute;s ter recebido o <FONT FACE="Courier, monospace">FileObject</FONT> retornado de <FONT FACE="Courier, monospace">getSerializedFile()</FONT>, voc&ecirc; poderia gravar dados XML t&atilde;o f&aacute;cil como usar <FONT FACE="Courier, monospace">ObjectOutputStream</FONT>.</P>
<H4>EntryListComponent</H4>
<P><FONT FACE="Times New Roman">Esta classe define um componente que ir&aacute; abrir no centro, ou o modo &quot;editor&quot;, e conter uma lista de novos itens de uma alimenta&ccedil;&atilde;o &uacute;nica</FONT>.</P>
<PRE>public class EntryListComponent extends TopComponent 
{
    protected static final String PREFERRED_ID = &quot;rss_entry_list&quot;; //NOI18N
    
    protected String preferredID() { 
        return PREFERRED_ID;
    } </PRE><P>
N&atilde;o h&aacute; nada de estranho acontecendo com as IDs nesta classe. Elas est&atilde;o apenas agindo como uma dica para o sistema Windows.</P>
<PRE>    public static TopComponent getInstance(Feed feed)
    {
        // look for an open instance containing this feed
        Iterator opened = TopComponent.getRegistry().getOpened().iterator();
        while (opened.hasNext())
        {
            Object tc = opened.next();
            if (tc instanceof EntryListComponent)
            {
                EntryListComponent elc = (EntryListComponent)tc;
                if (feed.equals(elc.m_feed))
                {
                    elc.initData(feed);
                    return elc;
                }
            }
        }
        
        // none found, make a new one
        return new EntryListComponent(feed);
    }</PRE><P>
O m&eacute;todo <FONT FACE="Courier, monospace">getInstance()</FONT> assegura que somente uma inst&acirc;ncia existe para cada alimenta&ccedil;&atilde;o &uacute;nica. Portanto, poder&aacute; haver diversas abas abertas de uma vez, mas osmente uma para cada URL de alimenta&ccedil;&atilde;o.</P>
<PRE>    
    protected EntryListComponent(Feed feed) 
    {
        super();
        initComponents();
        if (feed != null)
            initData(feed);
    }</PRE><P>
Torne o construtor protegido, portanto, os clientes t&ecirc;m de usar <FONT FACE="Courier, monospace">getInstance()</FONT>.</P>
<PRE>    
    protected void initData(Feed feed)
    {
        m_list.setFeed(feed);
        setDisplayName(feed.toString());
        
        m_feed = feed;
    }</PRE><P>
D&ecirc; a alimenta&ccedil;&atilde;o &agrave; <FONT FACE="Courier, monospace">JList</FONT>, e defina o nome de exibi&ccedil;&atilde;o, que ser&aacute; usado na aba de componentes e nos menus do Windows, etc.</P>
<PRE>    public int getPersistenceType() {
        return PERSISTENCE_NEVER;
    }</PRE><P>
Ao fechar o NetBeans, n&atilde;o se preocupe em serializar estas componentes.</P>
<h3 class='tutorial'>EntryList, BrowserFrame, Feed</h3>
<P>Essas classes n&atilde;o cont&ecirc;m muito c&oacute;digo espec&iacute;fico do NetBeans. Deixarei que os coment&aacute;rios nos c&oacute;digos falem por si pr&oacute;prios.</P>
<h2>Teste!</h2>
<P>No diret&oacute;rio <FONT FACE="Courier, monospace">nbbuild/</FONT>, execute <B><FONT FACE="Courier, monospace">ant</FONT></B>. A seguir, execute <B><FONT FACE="Courier, monospace">/home/rich/netbeans/rssreader1/bin/rss-reader.sh</FONT></B> (ou <B><FONT FACE="Courier, monospace">rss-reader.bat</FONT></B> no Windows). Voc&ecirc; deve agora ver uma lista vazia na esquerda &agrave; qual &eacute; poss&iacute;vel adicionar URLs de alimenta&ccedil;&atilde;o.</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><IMG SRC="../../images_www/articles/win-with-netbeans/feedreader-nobrand.jpg" NAME="Unbranded FeedReader" ALIGN=MIDDLE WIDTH=957 HEIGHT=714 BORDER=0></P>
<P>Um FeedReader funcional! H&aacute; apenas uma coisa errada. Ainda parece como uma capacidade RSS atrelada ao NetBeans. Ainda h&aacute; bot&otilde;es da barra de feramentas e itens de menu que n&atilde;o fazem nada de &uacute;til para a leitura de RSS.</P>
<h2>Nomea&ccedil;&atilde;o</h2>
<P>O m&oacute;dulo de nomea&ccedil;&atilde;o do FeedReader &eacute; um m&oacute;dulo bastante simples. N&atilde;o h&aacute; nenhum c&oacute;digo Java. Apenas um arquivo de camadas que oculta diversas barras de ferramentas e itens de menu:</P>
<PRE>    &lt;folder name=&quot;Toolbars&quot;&gt;
        &lt;folder name=&quot;File_hidden&quot;/&gt;
        &lt;folder name=&quot;Edit_hidden&quot;/&gt;
    &lt;/folder&gt;
    
    &lt;folder name=&quot;Menu&quot;&gt;
        &lt;folder name=&quot;File&quot;&gt;
            &lt;file name=&quot;org-openide-actions-SaveAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-openide-actions-SaveAllAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-netbeans-core-actions-RefreshAllFilesystemsAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-openide-actions-PageSetupAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-openide-actions-PrintAction.instance_hidden&quot;/&gt;
        &lt;/folder&gt;
        
        &lt;folder name=&quot;Edit_hidden&quot;/&gt;
        
        &lt;folder name=&quot;View&quot;&gt;
            &lt;!-- hide the default web browser that doesn't render stuff very well --&gt;
            &lt;file name=&quot;org-netbeans-core-actions-HTMLViewAction.instance_hidden&quot;/&gt;
        &lt;/folder&gt;
        
        &lt;folder name=&quot;Window&quot;&gt;
            &lt;file name=&quot;org-netbeans-core-actions-GlobalPropertiesAction.instance_hidden&quot;/&gt;
        &lt;/folder&gt;
    &lt;/folder&gt;</PRE><P>
A pergunta que acho que voc&ecirc; deseja fazer &eacute;: &quot;Como sab&iacute;amaos os nomes de todos esses arquivos a serem ocultados?&quot;. Certamente n&atilde;o &eacute; &oacute;bvio que para ocultar o item de menu &quot;Arquivo...Salvar&quot;, &eacute; necess&aacute;rio especificar <FONT FACE="Courier, monospace">&lt;file name=”org-openide-actions-SaveAction.instance_hidden”/&gt;</FONT>. Bom, h&aacute; duas maneiras. Voc&ecirc; pode ca&ccedil;ar no c&oacute;digo-fonte do NetBeans, procurando pelo arquivos de camadas onde ele foi originalmente declarado. Ou, voc&ecirc; pode usar o Bean Browser, uma ferramenta inclu&iacute;da no m&oacute;dulo “Open APIs Support” (org-netbeans-modules-apisupport) no Centro de Atualiza&ccedil;&atilde;o do NetBeans. Isso cria um n&oacute; na janela “Windows...Execut&aacute;vel” denominado “Bean Browser” que permite procurar no system filesystem. 
</P>
<P>Ferramenta bem &uacute;til.</P>
<P>Al&eacute;m do arquivo de camadas, h&aacute; outro aspecto n&atilde;o usual para o m&oacute;dulo de nomea&ccedil;&atilde;o. No scirpt do build, voc&ecirc; ver&aacute; as se&ccedil;&otilde;es agora familiares que adicionam arquivos de recursos ao arquivo de implementa&ccedil;&atilde;o definido:</P>
<PRE>    &lt;!-- 
    Identifies all the files to be considered part of this module when deployed 
    --&gt;
    &lt;target name=&quot;files-init&quot; depends=&quot;basic-init&quot;&gt;
        &lt;patternset id=&quot;module.files&quot;&gt;
            &lt;include name=&quot;${module.jar}&quot;/&gt;
            &lt;include name=&quot;${javahelp.jar}&quot; if=&quot;has.javahelp&quot;/&gt;
            &lt;include name=&quot;${nb.system.dir}/Modules/${code.name.base.dashes}.xml&quot;/&gt;

            &lt;!-- additions for FeedReader begin here --&gt;
            &lt;include name=&quot;${nb.lib.dir}/locale/core_rss.jar&quot;/&gt;
            &lt;include name=&quot;${nb.modules.dir}/locale/org-netbeans-core-windows_rss.jar&quot;/&gt;
        &lt;/patternset&gt;
    &lt;/target&gt;

    &lt;!-- 
    netbeans-extra is a hook provided to plug in file copying. 
    --&gt;
    &lt;target name=&quot;netbeans-extra&quot; depends=&quot;init&quot;&gt;
        &lt;mkdir dir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.lib.dir}/locale&quot;/&gt;
        &lt;mkdir dir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/locale&quot;/&gt;

        &lt;jar destfile=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.lib.dir}/locale/core_rss.jar&quot; 
             basedir=&quot;core&quot;/&gt;
        &lt;jar destfile=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/locale/org-netbeans-core-windows_rss.jar&quot; 
             basedir=&quot;core-windows&quot;/&gt;
    &lt;/target&gt;</PRE><P>
Neste caso, voc&ecirc; est&aacute; adicionando dois arquivos jar: <FONT FACE="Courier, monospace">core_rss.jar</FONT> e <FONT FACE="Courier, monospace">org-netbeans-core-windows_rss.jar</FONT>. Estes jars correspondem ao <FONT FACE="Courier, monospace">core.jar</FONT> e <FONT FACE="Courier, monospace">org-netbeans-core-windows.jar</FONT>. De fato, qualquer jar no NetBeans padr&atilde;o instalado, pode ser &quot;nomeado&quot; ao colocar outro jar relativo ao original:</P>
<PRE>/path/to/original.jar
/path/to/locale/original_brandname.jar</PRE><P>
Lembre-se que o script do shell no m&oacute;dulo JDIC passa “&ndash;branding rss” como um par&acirc;metro. Portanto, o “brandname” neste caso e “rss”.</P>
<P>Quase todos os arquivos de recursos pode ser nomeado. &Iacute;cones, conjuntos, arquivos de camada, etc. No <FONT FACE="Courier, monospace">core_rss.jar</FONT>, Eu dei o nome &agrave; tela splash e um conjunto de recursos, que cont&ecirc;m chaves que afetam como a tela splash &eacute; exibida. No <FONT FACE="Courier, monospace">org-netbeans-core-windows_rss.jar</FONT>, Eu dei o nome &agrave; apenas um conjunto, para sobrepor o texto da barra de t&iacute;tulos principal.</P>
<h2>Teste novamente!</h2>
<P>Agora voc&ecirc; deveria ver uma tela como a captura de tela no in&iacute;cio deste artigo. E agora voc&ecirc; sabe como redigir um aplicativo real para a plataforma NetBeans.</P>
<h2>Perguntas?</h2>
<P>Mande suas perguntas para a lista de correio <A HREF="mailto:dev@openide.netbeans.org">dev@openide.netbeans.org</A>. Consulte <A HREF="https://netbeans.org/community/lists/top.html">https://netbeans.org/community/lists/top.html</A> para obter informa&ccedil;&otilde;es sobre listas de correio do NetBeans.</P>
</BODY>
</HTML>

