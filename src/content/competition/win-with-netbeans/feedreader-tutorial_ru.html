<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-8">
	<TITLE>FeedReader</TITLE>
	
	<link rel="stylesheet" type="text/css" href="../../netbeans.css">
	<STYLE>
	<!--
		@page { size: 8.5in 11in }
		PRE { color: #808000 }
		P.boxnote { margin-left: 0.2in; margin-right: 0.2in; margin-top: 0.2in; margin-bottom: 0.2in; border: 1.00pt solid #9999cc; padding: 0.1in; color: #666699 }
		BLOCKQUOTE.western { font-style: italic }
	-->
	</STYLE>
</HEAD>
<BODY >
<H1>FeedReader</H1>
<b>Автор: Рих Унгер (Rich Unger)</b>
<br><i>Статья написана в рамках соревнования Победа с NetBeans</i> 
<p></p>
<H2 >Пример и учебный курс по платформе NetBeans</H2>

<P><IMG SRC="../../images_www/articles/win-with-netbeans/feedreader-branded.jpg" NAME="Finished FeedReader" ALIGN=MIDDLE WIDTH=957 HEIGHT=714 BORDER=0>
</P>
<h2>Какова функция FeedReader?</h2>
<P>FeedReader представляет собой простейший обозреватель каналов RSS/Atom, построенный по принципу подключаемого модуля <A HREF="https://addons.mozilla.org/de/firefox/addon/77/">Sage</A> для Mozilla Firefox. FeedReader состоит из следующих элементов:</P>
<UL>
	<LI><P>список каналов (адресов URL, указывающих на файлы описания rss/rdf/atom);</P>
	<LI><P>список заголовков из каждого канала;</P>
	<LI><P>окно обозревателя (mozilla, встроенная во фрейм JFrame).</P>
</UL>
<P>Встроенный фрейм mozilla предоставляется библиотекой <A HREF="https://jdic.dev.java.net/">JDIC</A>, использующей вызовы JNI. Этот пример настроен для работы с двоичными файлами JDIC как для ОС Linux, так и для ОС Windows.</P>
<H3>Кому предназначен этот учебный курс?</H3>
<P>Этот курс предназначен в первую очередь для разработчиков приложений на платформе NetBeans. Предпринимается попытка полного документирования создания приложения FeedReader и назначения каждой строки манифестов, файлов слоя, исходных файлов Java, особенно в случаях, когда пришлось применять неочевидные решения.</P>
<P>Такова вторичная задача этого учебного курса. Неочевидные решения и способы обхода проблем выделяются &quot;рамкой хитростей&quot;:</P>
<P CLASS="boxnote">для выполнения этого действия необходимо сделать кое-что хитрое.</P>
<P>Во всех таких случаях приводится ссылка на соответствующую открытую проблему в IssueZilla. Следует надеяться, что этот документ продолжит развиваться, и &quot;рамки хитростей&quot; со временем исчезнут, в результате чего на платформе станет проще разрабатывать приложения.</P>
<h2>Начало работы</h2>
<P>Приведен полный <A HREF="https://netbeans.org/files/documents/4/296/feedreader-source.zip">исходный код</A>.</P>
<P>В настоящем учебном курсе не предполагается использование какой-либо конкретной среды IDE. Предположим даже, что используется текстовый редактор, пакет JDK 1.5.0 (ошибка версии 1.4.x не позволяет скомпилировать этот пример, однако он <i>выполняется</i> в 1.4.x) и Apache Ant версии 1.6.2 или более поздней. Для упрощения примеров работы с командной строкой подразумевается использование интерпретатора команд bash (в Unix или Cygwin). Желающие могут переводить на язык интерпретатора командной строки Windows. Это тоже сработает. </P>
<P>Хотелось бы избежать смешивания <b>среды IDE</b> NetBeans и <b>платформы</b> NetBeans. Сначала пройдите этот учебный курс. Добейтесь понимания принципа действия модулей. И только потом можно задумываться о средствах (например, среде IDE NetBeans) для снижения трудоемкости разработки.</P>
<P>Прежде всего для начала работы потребуется копия платформы NetBeans. Ее необязательно строить из исходного кода. Можно просто загрузить <A HREF="/downloads/">двоичный выпуск</A> и распаковать его в удобном месте. Например, в папке <FONT FACE="Courier, monospace">/home/rich/netbeans.</FONT></P>
<P>Затем неплохо было бы раздобыть примеров исходного кода. Автор, например, начинал с <A HREF="http://contrib.netbeans.org/files/documents/130/269/cluster_build_harness.zip">инвентаря для построения кластера</A>. Это было достаточно удобно, поскольку уже были созданы скрипты построения Ant для построения и упаковки модулей, и был создан модуль запуска &quot;snipe&quot;. Разумеется, с тем же успехом можно начать приложение с дерева исходного кода для FeedReader. 
</P>
<P>Инвентарь для построения кластера был распакован автором в каталог <FONT FACE="Courier, monospace">/home/rich/src/rss.</FONT></P>
<P>Наконец, потребуется настройка скриптов построения для обнаружения установленной платформы NetBeans. </P>
<P>Измените несколько строк в файле <FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/user.build.properties</FONT>:</P>
<PRE><FONT COLOR="#808000">netbeans.dest.dir=/home/rich/netbeans</FONT>
<FONT COLOR="#808000">clustername=rssreader1</FONT></PRE><P>
Имена кластеров традиционно снабжаются обозначением версии в конце, однако это не строгое требование.</P>
<BLOCKQUOTE CLASS="western">Определение: <B>кластер</B> &mdash; это набор модулей и связанных с ними файлов ресурсов. Установка NetBeans может состоять из набора кластеров, которые выбираются при запуске NetBeans. В среде IDE NetBeans, например, выполняются кластеры platform4, ide4, nb4.0 и extra. Идея кластеров заключается в том, чтобы использовать единственную установку платформы NetBeans с несколькими брэндированными приложениями, использующими одни и те же кластеры. Например, можно установить кластер rssreader1 в установку среды IDE NetBeans и посредством двух разных скриптов запуска запускать среду IDE и FeedReader, причем каждое из приложений использовало бы кластер platform4, однако в остальном приложения оставались бы раздельными.</BLOCKQUOTE>
<P>Теперь изменим несколько строк в файле <FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/user.cluster.properties</FONT> для синхронизации имени кластера с указанным в файле <FONT FACE="Courier, monospace">user.build.properties</FONT>:</P>
<PRE>user.cluster=cluster.rssreader1
cluster.rssreader1.dir=rssreader1
cluster.rssreader1= snipe</PRE><P>
Теперь при запуске средства <B><FONT FACE="Courier, monospace">ant</FONT></B> в каталоге <FONT FACE="Courier, monospace">nbbuild/</FONT> создается каталог <FONT FACE="Courier, monospace">/home/rich/netbeans/rssreader1</FONT> с модулем snipe. Разумеется, модуль snipe не требуется, поэтому необходимо ввести команду <B><FONT FACE="Courier, monospace">ant clean</FONT></B> для его устранения.</P>
<P>Пора перейти к действительно необходимым модулям.</P>
<h2>Модули библиотек</h2>
<P>Все приложение FeedReader можно упаковать в один модуль. Но это было бы... не слишком... модульно. Так вышло, что FeedReader требует библиотек JDOM, Rome и JDIC. Если требуется расширить это приложение дополнительными модулями, которые могут использовать эти библиотеки, предпочтительна зависимость только от одного модуля библиотеки, а не от всего приложения FeedReader. Кроме того, модули библиотек могут загружаться автоматически.</P>
<BLOCKQUOTE CLASS="western">Определение: модуль <B>автоматической загрузки</B> &mdash; это модуль, который загружается NetBeans, когда он требуется (для другого модуля). Пока модуль не требуется, он не занимает память.</BLOCKQUOTE>
<H4>Добавление модулей к дереву исходного кода</H4>
<P>При добавлении модуля необходимо предоставить информацию о нем инвентарю построения. Измените два файла.</P>
<P><FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/user.cluster.properties:</FONT></P>
<PRE>cluster.rssreader1=snipe, \
                   anothermodule, \
                   yetanother</PRE><P>
Таким образом скриптам построения предоставляется список модулей в кластере, и кластер может быть построен в виде блока в каталоге, указанном как местоположение итоговых файлов JAR.</P>
<P><FONT FACE="Courier, monospace">/home/rich/src/rss/nbbuild/modules.xml:</FONT></P>
<PRE>&lt;module&gt;
  &lt;path&gt;snipe&lt;/path&gt;
  &lt;cnb&gt;org.netbeans.modules.snipe&lt;/cnb&gt;
&lt;/module&gt;</PRE><P>
Таким образом имя каталога, содержащего исходный код модуля, ставится в соответствие с именем, под которым этот каталог будет известен во время выполнения (&quot;cnb&quot; расшифровывается как &quot;code-name-base&quot; &mdash; основа кодового имени).</P>
<H4>JDOM</H4>
<P>Вероятно, большинство читателей знакомо с JDOM. Это интерфейс API для синтаксического анализа XML, который требуется для FeedReader исключительно потому, что он используется библиотекой Rome.</P>
<P>Начнем с добавления &quot;jdom&quot; к списку кластера и 
</P>
<PRE>&lt;module&gt;
  &lt;path&gt;jdom&lt;/path&gt;
  &lt;cnb&gt;org.jdom.api&lt;/cnb&gt;
&lt;/module&gt;</PRE><P>
к списку модулей. Ниже приведен список файлов модулей JDOM:</P>
<PRE>build.xml
manifest.mf
nbproject/project.xml
nbproject/project.properties
lib/jdom.jar
src/org/jdom/api/Bundle.properties</PRE><P>
Рассмотрим их по одному.</P>
<P><B>build.xml</B>: в начале файла построения выполняется импорт другого файла построения с именем projectized.xml. Обычно это все, что требуется в файле построения модуля. Однако в модуле JDOM необходимо добавить к пакету модуля файл jdom.jar в дополнение к собственному файлу jar модуля.</P>
<P CLASS="boxnote">Хитрость №1: для включения дополнительных библиотек не должно требоваться переопределение поведения построения. Такие зависимости должны объявляться в файле project.xml, и скрипты построения должны быть способны определить способ создания соответствующих записей манифеста, включаемых в файл nbm. 
<BR><BR><A HREF="https://netbeans.org/bugzilla/show_bug.cgi?id=52354">https://netbeans.org/bugzilla/show_bug.cgi?id=52354</A></P>
<P>Итак, переопределите две цели. Цель &quot;files-init&quot; представляет собой точную копию цели из файла projectized.xml, в которую добавлена следующая строка:</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;include name=&quot;${nb.modules.dir}/ext/jdom.jar&quot;/&gt;</PRE><P>
Цель &quot;files-init&quot; предоставляет скриптам построения список файлов, принадлежащих к модулю. Эти файлы удаляются при выполнении цели &quot;clean&quot;. По традиции файлы jar, которые не являются модулями, располагаются в каталоге <FONT FACE="Courier, monospace">ext/</FONT>.
<p>Также необходимо переопределить цель &quot;netbeans-extra&quot;. Это привязка, предоставляемая скриптами построения для выполнения таких действий как копирование файлов в ходе процесса развертывания.</P>
<PRE>&lt;target name=&quot;netbeans-extra&quot; depends=&quot;init&quot;&gt;
    &lt;mkdir dir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/ext&quot;/&gt;
    &lt;copy todir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/ext&quot;&gt;
      &lt;fileset dir=&quot;lib&quot;&gt;
        &lt;include name=&quot;jdom.jar&quot;/&gt;
      &lt;/fileset&gt;
    &lt;/copy&gt;
&lt;/target&gt;</PRE><P>
При этом файл jdom.jar копируется в каталог <FONT FACE="Courier, monospace">/home/rich/netbeans/rssreader1/modules/ext.</FONT></P>
<P><FONT FACE="Times New Roman"><B>manifest.mf</B>: для каждого файла jar требуется манифест. Модуль NetBeans представляет собой просто файл jar, в манифесте которого есть по крайней мере следующие две строки:</FONT></P>
<PRE>OpenIDE-Module: org.jdom.api/1
OpenIDE-Module-Specification-Version: 1.0</PRE><P>
Первая строка &mdash; имя модуля и, возможно, версия выпуска (<I>release-version</I>). Обратите внимание на то, что это имя совпадает с &lt;cnb&gt; (основа кодового имени) из файла modules.xml.</P>
<P STYLE="font-style: normal">Вторая строка &mdash; версия спецификации модуля <I>specification-version</I>.</P>
<BLOCKQUOTE CLASS="western">Остановимся подробнее на номерах версий... С модулем могут быть связаны 3 разных номера версии: <B>release-version</B>, <B>specification-version</B> и <B>implementation-version</B> (версия реализации). 
</BLOCKQUOTE>
<BLOCKQUOTE CLASS="western">Предположим, например, что модуль A обладает версией выпуска 1, версией спецификации 2.0 и версией реализации beta3. Модуль B в свою очередь декларирует (в своем файле project.xml) зависимость от модуля A. В модуле <SPAN STYLE="text-decoration: none"><SPAN STYLE="font-style: normal">обязательно</SPAN> должна быть указана версия выпуска 1. <SPAN STYLE="font-style: normal">В необязательном порядке</SPAN> может быть указана зависимость от версии спецификации 2.0. Если такая зависимость указана, а автор модуля A выпустит версию 2.1, зависимость не нарушится. Соглашение заключается в том, что публичные классы интерфейса API, предъявляемые модулем A (см. элемент &lt;public-packages&gt; в файле project.xml) не нарушают совместимость. Зависимость от версии спецификации лишь предоставляет модулю B доступ к этим классам интерфейса API. </SPAN>
</BLOCKQUOTE>
<BLOCKQUOTE CLASS="western" STYLE="text-decoration: none"><I>Если для модуля B указана зависимость от версии реализации beta3, этот модуль будет работать только с такой версией модуля A. Однако модуль B будет иметь доступ ко всем публичным классам модуля A. (Если при выполнении модуля выдается исключение NoClassDefFoundException, это может быть связано с попыткой доступа к классам, не являющимся частью интерфейса API, без указания зависимости реализации).</I></BLOCKQUOTE>
<P>Добавьте 2 строки к манифесту:</P>
<PRE>OpenIDE-Module-Localizing-Bundle: org/jdom/api/Bundle.properties
Class-Path: ext/jdom.jar</PRE><P>
Первая строка необязательна к использованию. Она указывает на набор, содержащий дополнительные записи манифеста. Все эти записи манифеста являются локализуемыми строками, такими как отображаемое имя и описание модуля.</P>
<P>Вторая строка &mdash; это стандартная запись пути к классам манифеста, которая располагает файл jdom.jar в пути к классам файла jar модуля. Обратите внимание, что путь &quot;ext/jdom.jar&quot; совпадает с местоположением файла jdom.jar в файле build.xml.</P>
<P CLASS="boxnote">Хитрость №2: следовало бы обойтись без указания пути к классам. Он должен генерироваться автоматически (обратитесь к Хитрости №1).</P>
<P><B>nbproject/project.xml</B>: этот файл указывает скриптам построения (и среде IDE, если таковая используется), каким образом следует генерировать декларации о зависимости и пути к классам. Здесь также должны быть указаны уже знакомые нам данные &lt;code-name-base&gt; и &lt;path&gt;. Затем необходимо указать все зависимости от других модулей. Поскольку в самом модуле код отсутствует, а файл jdom.jar не требует какого-либо кода кроме базовых классов JRE, объявлять здесь нечего. Тем не менее, всегда необходимо объявлять зависимость от базовых классов OpenAPI:</P>
<PRE>&lt;dependency&gt;
  &lt;code-name-base&gt;org.openide&lt;/code-name-base&gt;
    &lt;build-prerequisite/&gt;
    &lt;compile-dependency/&gt;
    &lt;run-dependency&gt;
      &lt;release-version&gt;1&lt;/release-version&gt;
      &lt;specification-version&gt;4.5&lt;/specification-version&gt;
  &lt;/run-dependency&gt;
&lt;/dependency&gt;</PRE><P>
Это нечто вроде особого случая. Если эти зависимости не указаны, причем со свежей версией спецификации, NetBeans считает, что модуль старый, и автоматически загружает при выполнении набор зависимостей в целях обеспечения обратной совместимости.</P>
<P>Затем необходимо объявить для модуля <FONT FACE="Courier, monospace">&lt;public-packages&gt;</FONT>. Таким образом решаются две задачи: публичные пакеты становятся доступными для других модулей, объявивших зависимость от данного модуля, и они формируют набор пакетов для генерации документации Javadoc при выполнении цели Ant &quot;javadoc&quot;.</P>
<P>Можно либо указать каждый пакет отдельно:</P>
<PRE>&lt;public-packages&gt;
  &lt;package&gt;org.jdom&lt;/package&gt;
  &lt;package&gt;org.jdom.adapters&lt;/package&gt;
  &lt;package&gt;org.jdom.input&lt;/package&gt;
  ...
&lt;/public-packages&gt;</PRE><P>
либо все дерево одной строкой:</P>
<PRE>&lt;public-packages&gt;
  &lt;subpackages&gt;org.jdom&lt;/subpackages&gt;
&lt;/public-packages&gt;</PRE><P>
Этот метод, однако, не работает с целью &quot;javadoc&quot;.</P>
<P><B>project.properties</B>: еще несколько подсказок для процесса построения...</P>
<PRE>is.autoload=true
cp.extra=lib/jdom.jar
module.javadoc.packages=org.jdom</PRE><P>
В первой строке модуль объявляется как автоматически загружаемый (<I>autoload</I>). Вторая строка добавляется к пути к классам при компиляции. Третья строка требуется, если публичные пакеты (<FONT FACE="Courier, monospace">&lt;public-packages&gt;</FONT>) в файле project.xml объявлены с помощью метода <FONT FACE="Courier, monospace">&lt;subpackages&gt;</FONT>.</P>
<P CLASS="boxnote">Хитрость №3: здесь можно было бы обойтись без указания module.javadoc.packages. Скрипты построения должны обладать адекватным режимом &quot;отступления&quot; в предположении, что пользователь не заинтересован в документации Javadoc для этого модуля. На момент публикации если эта строка не указана, построение прерывается.<BR><BR><A HREF="https://netbeans.org/bugzilla/show_bug.cgi?id=52135">https://netbeans.org/bugzilla/show_bug.cgi?id=52135</A>
<br><br>* Обновление: исправлено в выпуске NetBeans 4.1</P>
<h3 class='tutorial'>Rome</h3>
<H3>Rome</H3>
<P>Библиотека <A HREF="https://rome.dev.java.net/">Rome</A> считывает каналы RSS и Atom (необходимо добавить, что интерфейс API очень прост). Модуль Rome и модуль JDOM отличаются только в двух отношениях. В модуль Rome входят два файла jar (rome-0.4.jar и rome-fetcher-0.4.jar) вместо одного, а в файле project.xml объявляется зависимость от модуля JDOM:</P>
<PRE>&lt;dependency&gt;
  &lt;code-name-base&gt;org.jdom.api&lt;/code-name-base&gt;
  &lt;build-prerequisite/&gt;
  &lt;compile-dependency/&gt;
  &lt;run-dependency&gt;
    &lt;release-version&gt;1&lt;/release-version&gt;
    &lt;specification-version&gt;1.0&lt;/specification-version&gt;
  &lt;/run-dependency&gt;
&lt;/dependency&gt;</PRE><H3>
JDI</H3>
<P>Библиотека <A HREF="https://jdic.dev.java.net/">JDIC</A> позволяет программам на Java пользоваться такими средствами настольной среды как обозреватели, почтовые программы, системные области уведомлений и реестры типов MIME. В FeedReader для визуализации веб-страниц во фрейме JFrame с помощью механизма визуализации IE или Mozilla используется встроенный компонент обозревателя.</P>
<P>Для этого из JDIC выполняются вызовы Java Native Interface (JNI) к общей библиотеке (<FONT FACE="Courier, monospace">jdic.dll</FONT> или <FONT FACE="Courier, monospace">libjdic.so</FONT>), а также выполняются исполняемые файлы (<FONT FACE="Courier, monospace">IeEmbed.exe</FONT> или <FONT FACE="Courier, monospace">mozembed-linux-gtk2</FONT>). Чтобы эти библиотеки и исполняемые файлы были доступны для NetBeans во время выполнения, в файле компоновки модуля нужно немного пошаманить.</P>
<P>Обратите внимание на набор файлов, объявленных в задаче &quot;files-init&quot;:</P>
<PRE>&lt;include name=&quot;${nb.modules.dir}/ext/jdic.jar&quot;/&gt;
&lt;include name=&quot;lib/libjdic.so&quot;/&gt;
&lt;include name=&quot;lib/libmozembed-linux-gtk1.2.so&quot;/&gt;
&lt;include name=&quot;lib/libmozembed-linux-gtk2.so&quot;/&gt;
&lt;include name=&quot;lib/mozembed-linux-gtk1.2&quot;/&gt;
&lt;include name=&quot;lib/mozembed-linux-gtk2&quot;/&gt;
&lt;include name=&quot;lib/jdic.dll&quot;/&gt;
&lt;include name=&quot;lib/IeEmbed.exe&quot;/&gt;
&lt;include name=&quot;lib/nspr4.dll&quot;/&gt;
&lt;include name=&quot;bin/${shell.script}&quot;/&gt;
&lt;include name=&quot;bin/${batch.script}&quot;/&gt;</PRE><P>
Помимо уже знакомого объявления файла jar указан ряд собственных библиотек и исполняемых файлов из каталога <FONT FACE="Courier, monospace">lib/</FONT> и пара скрипов. Решение расположить собственные файлы в этом конкретном каталоге несколько произвольно, однако именно это местоположение предлагается в <A HREF="http://openide.netbeans.org/proposals/arch/installation.html#logical">документе по архитектуре</A>. Это местоположение должно быть известно еще в одном месте &mdash; для скриптов запуска.</P>
<P>Скрипт интерпретатора команд и пакетный скрипт генерируются целью <FONT FACE="Courier, monospace">shellscript</FONT> файла построения. Эти скрипты запускают платформу NetBeans с кластером rssreader1 и двоичными файлами jdic по соответствующим путям. </P>
<h2>Модуль FeedReader</h2>
<P>Теперь, когда собраны все требуемые модули библиотек, можно наконец создать модуль, который что-то <I>делает</I>.</P>
<P STYLE="font-style: normal">Начнем с создания скриптов построения и декларативных элементов модуля. Файл <FONT FACE="Courier, monospace">build.xml</FONT> девственно чист и содержит лишь одну строку импорта для стандартного файла &quot;projectized.xml&quot;. Файл <FONT FACE="Courier, monospace">nbproject/project.xml</FONT> просто объявляет зависимости от трех модулей библиотек и не содержит публичных пакетов (в этих модулях не предоставляется интерфейсов API для других модулей). Файл <FONT FACE="Courier, monospace">nbproject/project.properties</FONT> также пуст. Файл <FONT FACE="Courier, monospace">manifest.mf</FONT>, вероятно, также выглядит знакомо. В нем всего один новый элемент:</P>
<PRE STYLE="margin-bottom: 0.2in">OpenIDE-Module-Layer: org/netbeans/modules/feedreader/resources/layer.xml</PRE><P>
В отличие от модулей библиотек в файле слоя содержатся объявления о пользовательском интерфейсе FeedReader для включения в &quot;системную файловую систему&quot;.</P>
<BLOCKQUOTE CLASS="western">Определение: в <B>системной файловой системе</B> хранятся все системные параметры настройки, данные о компоновке графического интерфейса пользователя, действия, шаблоны и практически все что требуется для поддержания состояния установки NetBeans. Эта системная файловая система состоит из настоящих файлов, расположенных в каталоге &quot;config&quot; каждого кластера и в каталоге &quot;config&quot; пользовательского каталога NetBeans, а также из виртуальных &quot;файлов&quot;, объявленных в файлах слоя модуля.
</BLOCKQUOTE>
<h3 class='tutorial'>Файл слоя</h3>
<P>Первая запись расположена в папке верхнего уровня <FONT FACE="Courier, monospace">Actions</FONT>. Это репозиторий для реализаций <FONT FACE="Courier, monospace">javax.swing.Action</FONT>. Эти реализации могут использоваться для пунктов меню, кнопок панелей инструментов и сочетаний клавиш. Добавление этой записи позволяет пользователям присваивать ViewFeedsAction сочетания клавиш путем выбора пункта меню &quot;Сервис ... Сочетания клавиш&quot;</P>
<P>Вторая запись размещает ViewFeedsAction в меню &quot;Вид&quot;. Обратите внимание на синтаксис теневого файла, который аналогичен символьной ссылке в UNIX или ярлыку в Windows.</P>
<P>Остальные записи располагаются в папке верхнего уровня <FONT FACE="Courier, monospace">Windows2</FONT>. В этой папке содержатся сведения о типах компонентов <A HREF="https://netbeans.org/download/4_0/javadoc/OpenAPIs/org/openide/windows/doc-files/api.html#overview-top">TopComponent</A>, для которых должны быть созданы экземпляры, и о местах их размещения. (Кстати папка называется &quot;Windows2&quot;, поскольку &quot;Windows&quot; &mdash; это старая оконная система до выпуска 3.6, оставленная ради обратной совместимости). В FeedReader содержатся два определения TopComponent: SiteListComponent и EntryListComponent. Последний предназначен для открытия в местоположении по умолчанию (по центру), поэтому переопределять это поведение в файле слоя не требуется. </P>
<P><FONT FACE="Courier, monospace">SiteListComponent</FONT>, однако, должен быть пристроен к левому краю, т.е. в режиме &quot;проводника&quot;. Поэтому добавим следующую запись:</P>
<PRE>&lt;folder name=&quot;Modes&quot;&gt;
    &lt;folder name=&quot;explorer&quot;&gt;            
        &lt;file name=&quot;rss_list.wstcref&quot; url=&quot;feedList.wstcref&quot;/&gt;
    &lt;/folder&gt;
&lt;/folder&gt;</PRE><P>
Таким образом объявляется, что <FONT FACE="Courier, monospace">TopComponent</FONT> с идентификатором “rss_list” должен быть пристроен по умолчанию в режиме проводника (&quot;explorer&quot;). (Кстати, расширение &quot;wstcref&quot; расшифровывается как <I>Window System Top Component REFerence</I> &mdash; ссылка на верхний компонент оконной системы). Расположение &quot;rss_list&quot; внутри объявленного режима выполняется на основании файла <FONT FACE="Courier, monospace">feedList.wstcref</FONT>:</P>
<PRE>&lt;tc-ref version=&quot;2.0&quot;&gt;
    &lt;module name=&quot;org.netbeans.modules.feedreader/1&quot; spec=&quot;1.0&quot; /&gt;
    &lt;tc-id id=&quot;rss_list&quot; /&gt;
    &lt;state opened=&quot;true&quot; /&gt;
&lt;/tc-ref&gt;</PRE><P>
Значение <FONT FACE="Courier, monospace">&lt;tc-id id&gt;</FONT> должно совпадать с базовым именем файла, объявленного в слое (&quot;rss_list&quot;). Это имя также должно присутствовать в папке <FONT FACE="Courier, monospace">Windows2/Components</FONT> с расширением “.settings”:</P>
<PRE>&lt;folder name=&quot;Components&quot;&gt;
    &lt;file name=&quot;rss_list.settings&quot; url=&quot;feedList.settings&quot; /&gt;
&lt;/folder&gt;</PRE><P>
Содержимое файла параметров настройки определяет способ создания экземпляра &quot;rss_list&quot;. Содержимое этого файла можно написать вручную, либо закомментировать весь раздел файла слоя &quot;Windows2&quot;, запустить NetBeans, создать экземпляр <FONT FACE="Courier, monospace">SiteListComponent</FONT> путем запуска <FONT FACE="Courier, monospace">ViewFeedsAction</FONT> и записать автоматически сгенерированный файл параметров настройки из каталога <FONT FACE="Courier, monospace">$userdir/config/Windows2Local/Component</FONT>. Затем замените раздел <FONT FACE="Courier, monospace">&lt;serialdata&gt;</FONT> следующим текстом:</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;instance class=&quot;org.netbeans.modules.feedreader.SiteListComponent&quot;/&gt;</PRE><P>
Таким образом создается компонент с помощью конструктора по умолчанию компонента <FONT FACE="Courier, monospace">SiteListComponent</FONT>. Если для класса требуется статический фабричный метод, можно добавить атрибут метода:</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;instance class=&quot;org.netbeans.modules.feedreader.SiteListComponent&quot; method=”makeSiteListComponent”/&gt;</PRE><H4>
ViewFeedsAction.java</H4>
<P>Теперь остается создать собственно код Java. Первый класс, объявленный в файле слоя &mdash; <FONT FACE="Courier, monospace">ViewFeedsAction.java</FONT>. Это простой подкласс класса <FONT FACE="Courier, monospace">CallableSystemAction</FONT>, представляющего собой реализацию <FONT FACE="Courier, monospace">javax.swing.Action</FONT> в виде единичного класса.</P>
<PRE>    public void performAction() {
        SiteListComponent.activate();
    }</PRE><P>
В результате выполнения этого действия открывается и получает фокус единичный экземпляр класса SiteListComponent (обратитесь к реализации SiteListComponent ниже).</P>
<PRE>    public String getName() {
        return NbBundle.getMessage(SiteListComponent.class, &quot;SLC_title&quot;);
    }</PRE><P>
Имя действия сохраняется в Bundle.properties, поэтому его можно локализовать.</P>
<PRE>    public HelpCtx getHelpCtx() {
        return HelpCtx.DEFAULT_HELP;
    }</PRE><P>
Этот код необходимо изменить, если существует более конкретная справка по этому действию в виде идентификатора JavaHelp или адреса URL.</P>
<PRE>    protected boolean asynchronous() {
        return false;
    }</PRE><P>
Более подробные сведения приведены в <A HREF="https://netbeans.org/download/4_0/javadoc/OpenAPIs/org/openide/util/actions/CallableSystemAction.html#asynchronous()">записи документации</A>.</P>
<h3 class='tutorial'>SiteListComponent.java</h3>
<P CLASS="boxnote">Хитрость №4: сравнительно непонятный код в этом классе (связанный с идентификаторами) обеспечивает единичность экземпляра SiteListComponent, идентификатор которого указан в файле слоя. В идеале должен бы существовать подкласс класса TopComponent, называемый, например, SingletonTopComponent, поскольку описываемая ситуация представляется распространенной.<BR><BR><A HREF="https://netbeans.org/bugzilla/show_bug.cgi?id=53252">https://netbeans.org/bugzilla/show_bug.cgi?id=53252</A></P>
<P>Следующий код обеспечивает единичность экземпляра:</P>
<PRE>    /** Подсказка оконной системе для генерации уникального идентификатора */
    private static final String PREFERRED_ID = &quot;rss_list&quot;; // NOI18N
    
    /** Фактический идентификатор (единичного) экземпляра */
    private static String s_id = PREFERRED_ID;

    ...

    public static synchronized SiteListComponent getInstance()
    {
        TopComponent c;
        c = WindowManager.getDefault().findTopComponent(s_id);
        if (c == null)
        {
            c = new SiteListComponent();
            s_id = WindowManager.getDefault().findTopComponentID(c);
        }
        return (SiteListComponent)c;
    }

    ...

    protected String preferredID() { 
        return PREFERRED_ID;
    }</PRE><P>
В NetBeans ведется карта всех компонентов <FONT FACE="Courier, monospace">TopComponent</FONT> в памяти. Ключ к этой карте здесь называется &quot;идентификатором&quot;. &quot;предпочтительный&quot; идентификатор &mdash; это просто подсказка, используемая оконной системой при создании нового экземпляра. <I>Гарантировать</I>, что эта подсказка возымеет какое-либо действие, невозможно. Просто обычно удобно иметь узнаваемое имя компонента при отслеживании проблем по содержимому <FONT FACE="Courier, monospace">$userdir/config/Windows2Local</FONT>.</P>
<P STYLE="font-style: normal">Статическое поле <FONT FACE="Courier, monospace">s_id</FONT>, однако, представляет собой идентификатор единственного экземпляра <FONT FACE="Courier, monospace">SiteListComponent</FONT> в памяти. По умолчанию установлено значение &quot;rss_list&quot;, поскольку это значение идентификатора указано в <FONT FACE="Courier, monospace">feedList.wstcref</FONT>. Следовательно, если пользователь использует модуль впервые, экземпляр компонента с идентификатором &quot;rss_list&quot; создается декларативно. Однако если пользователь закроет этот компонент, перезапустит NetBeans, а затем снова вызовет <FONT FACE="Courier, monospace">ViewFeedsAction</FONT>, новый компонент может получить другой идентификатор. Именно поэтому метод getInstance() может присвоить s_id новое значение.</P>
<P STYLE="font-style: normal">Если идентификатор действительно изменится, в файле слоя не будет никаких указаний на необходимость пристроить компонент в режиме &quot;проводника&quot;. Для принудительной реализации такого поведения необходимо переопределить метод open():</P>
<PRE>    private static final String MODE = &quot;explorer&quot;; // NOI18N

    public void open()
    {
        Mode m = WindowManager.getDefault().findMode(MODE);
        m.dockInto(this);
        super.open();
    }</PRE><P>
Остальная часть класса не является специфичной для NetBeans. Компонент состоит из JList и двух кнопок: одна из них добавляет канал, а вторая &mdash; удаляет выделенный канал. Со списком связан класс SiteListModel.</P>
<h3 class='tutorial'>SiteListModel</h3>
<P>Класс <FONT FACE="Courier, monospace">SiteListModel</FONT> добавляет сериализацию к классу Swing <FONT FACE="Courier, monospace">DefaultListModel</FONT>. После выполнения конструктора загружается список каналов с диска. Список на диске обновляется при каждой правке списка. (Чересчур? Возможно, однако список вряд ли будет слишком длинным, и после первоначальной настройки редко будет меняться).</P>
<P>Важно решить, <I>где</I> должна выполняться сериализация списка. Размещение его в системной файловой системе позволяет сделать сериализованный файл частью структуры файлов в <FONT FACE="Courier, monospace">$userdir/config</FONT>:</P>
<PRE>    private static final String DIR = &quot;FeedReader&quot;; //NOI18N
    private static final String FILENAME = &quot;feeds.ser&quot;; //NOI18N

    private FileObject getSerializedFile(boolean create) throws IOException
    {
        FileSystem sysFs = Repository.getDefault().getDefaultFileSystem();
        FileObject dir = sysFs.findResource(DIR);
        if (dir == null)
        {
            if (create)
                dir = sysFs.getRoot().createFolder(DIR);
            else
                return null;
        }
        
        FileObject fo = dir.getFileObject(FILENAME);
        if (fo == null)
        {
            if (create)
                fo = dir.createData(FILENAME);
            else
                return null;
        }
        
        return fo;
    }</PRE><P>
Булев параметр <FONT FACE="Courier, monospace">create</FONT> определяет, требуется ли создать файл, если он отсутствует (true для записи, false для чтения).</P>
<P>Итак, сериализованный список оказывается в каталоге <FONT FACE="Courier, monospace">$userdir/config/FeedReader/feeds.ser</FONT>.</P>
<P>Это несколько низкоуровневый подход к записи списка каналов. На самом деле существует интерфейс API NetBeans, способный взять на себя часть действий в этом направлении. Сериализацию можно реализовать путем создания подкласса <FONT FACE="Courier, monospace">SystemOption</FONT> и переопределения методов <FONT FACE="Courier, monospace">readExternal()</FONT> и <FONT FACE="Courier, monospace">writeExternal()</FONT>. Запись напрямую в системную файловую систему выбрана в этом учебном курсе, чтобы более наглядно продемонстрировать &quot;внутренности&quot; реализации. Кроме того, такая реализация предоставляет дополнительную гибкость: можно использовать другой формат файла. После получения объекта <FONT FACE="Courier, monospace">FileObject</FONT> от метода <FONT FACE="Courier, monospace">getSerializedFile()</FONT> для записи в него данных XML достаточно использовать <FONT FACE="Courier, monospace">ObjectOutputStream</FONT>.</P>
<H4>EntryListComponent</H4>
<P><FONT FACE="Times New Roman">Этот класс определяет компонент, открывающийся по центру в режиме &quot;редактора&quot; и содержащий список новостей из отдельного канала.</FONT></P>
<PRE>public class EntryListComponent extends TopComponent 
{
    protected static final String PREFERRED_ID = &quot;rss_entry_list&quot;; //NOI18N
    
    protected String preferredID() { 
        return PREFERRED_ID;
    } </PRE><P>
В этом классе нет никаких фокусов с идентификаторами. Они просто используются как подсказки для оконной системы. </P>
<PRE>    public static TopComponent getInstance(Feed feed)
    {
        // поиск открытого экземпляра, содержащего этот канал
        Iterator opened = TopComponent.getRegistry().getOpened().iterator();
        while (opened.hasNext())
        {
            Object tc = opened.next();
            if (tc instanceof EntryListComponent)
            {
                EntryListComponent elc = (EntryListComponent)tc;
                if (feed.equals(elc.m_feed))
                {
                    elc.initData(feed);
                    return elc;
                }
            }
        }
        
        // не найдено, создаем новый
        return new EntryListComponent(feed);
    }</PRE><P>
Метод <FONT FACE="Courier, monospace">getInstance()</FONT> обеспечивает уникальность экземпляра для каждого отдельного канала. Итак, может быть одновременно открыто несколько вкладок, но по одной для каждого адреса URL канала.</P>
<PRE>    
    protected EntryListComponent(Feed feed) 
    {
        super();
        initComponents();
        if (feed != null)
            initData(feed);
    }</PRE><P>
Конструктор должен быть защищенным, поэтому клиенты вынуждены использовать <FONT FACE="Courier, monospace">getInstance()</FONT>.</P>
<PRE>    
    protected void initData(Feed feed)
    {
        m_list.setFeed(feed);
        setDisplayName(feed.toString());
        
        m_feed = feed;
    }</PRE><P>
Передайте канал в <FONT FACE="Courier, monospace">JList</FONT> и установите отображаемое имя для использования на вкладке компонентов, в оконных меню и т.д.</P>
<PRE>    public int getPersistenceType() {
        return PERSISTENCE_NEVER;
    }</PRE><P>
При закрытии NetBeans эти компоненты не нуждаются в сериализации.</P>
<h3 class='tutorial'>EntryList, BrowserFrame, Feed</h3>
<P>В этих классах мало кода, специфичного для NetBeans. Комментарии в коде говорят сами за себя.</P>
<h2>Попробуйте сами!</h2>
<P>Запустите <B><FONT FACE="Courier, monospace">ant</FONT></B> в каталоге <FONT FACE="Courier, monospace">nbbuild/</FONT>. Затем запустите <B><FONT FACE="Courier, monospace">/home/rich/netbeans/rssreader1/bin/rss-reader.sh</FONT></B> (или <B><FONT FACE="Courier, monospace">rss-reader.bat</FONT></B> в Windows). Слева откроется пустой список, в который можно добавить адреса URL каналов.</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><IMG SRC="../../images_www/articles/win-with-netbeans/feedreader-nobrand.jpg" NAME="Unbranded FeedReader" ALIGN=MIDDLE WIDTH=957 HEIGHT=714 BORDER=0></P>
<P>FeedReader работает! Лишь один тревожный факт. Все это выглядит как поддержка RSS, неловко притуленная к NetBeans. Налицо кнопки панели инструментов и пункты меню, не имеющие никакого отношения к чтению RSS.</P>
<h2>Брэндинг</h2>
<P>Модуль брэндинга FeedReader весьма прост. В нем вообще нет кода Java. Только файл слоя, скрывающий ряд лишних пунктов меню и кнопок панели инструментов. </P>
<PRE>    &lt;folder name=&quot;Toolbars&quot;&gt;
        &lt;folder name=&quot;File_hidden&quot;/&gt;
        &lt;folder name=&quot;Edit_hidden&quot;/&gt;
    &lt;/folder&gt;
    
    &lt;folder name=&quot;Menu&quot;&gt;
        &lt;folder name=&quot;File&quot;&gt;
            &lt;file name=&quot;org-openide-actions-SaveAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-openide-actions-SaveAllAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-netbeans-core-actions-RefreshAllFilesystemsAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-openide-actions-PageSetupAction.instance_hidden&quot;/&gt;
            &lt;file name=&quot;org-openide-actions-PrintAction.instance_hidden&quot;/&gt;
        &lt;/folder&gt;
        
        &lt;folder name=&quot;Edit_hidden&quot;/&gt;
        
        &lt;folder name=&quot;View&quot;&gt;
            &lt;!-- скрыть обозреватель по умолчанию, который неважно работает --&gt;
            &lt;file name=&quot;org-netbeans-core-actions-HTMLViewAction.instance_hidden&quot;/&gt;
        &lt;/folder&gt;
        
        &lt;folder name=&quot;Window&quot;&gt;
            &lt;file name=&quot;org-netbeans-core-actions-GlobalPropertiesAction.instance_hidden&quot;/&gt;
        &lt;/folder&gt;
    &lt;/folder&gt;</PRE><P>
Несомненно, читателю любопытно, откуда автору известны названия всех этих скрываемых файлов. Не вполне очевидно, например, что для скрытия пункта меню &quot;Файл ... Сохранить&quot; необходимо указать <FONT FACE="Courier, monospace">&lt;file name=”org-openide-actions-SaveAction.instance_hidden”/&gt;</FONT>. Существуют два способа. Можно порыться в исходном коде NetBeans в поисках файла слоя, в котором требуемый элемент объявлен. Либо можно воспользоваться средством &quot;Bean Browser&quot;, которое включено в модуль &quot;Open APIs Support&quot; (org-netbeans-modules-apisupport) в центре обновления NetBeans. Это средство создает узел &quot;Bean Browser&quot; в окне &quot;Окна ... Среда выполнения&quot;, который позволяет выполнять обзор системной файловой системы. 
</P>
<P>Очень полезное средство.</P>
<P>Кроме файла слоя у модуля брэндинга есть еще один необычный аспект. В скрипте построения видны знакомые разделы, добавляющие файлы ресурсов к развернутому набору файлов:</P>
<PRE>    &lt;!-- 
    Перечень файлов, которые считаются частью модуля при развертывании 
    --&gt;
    &lt;target name=&quot;files-init&quot; depends=&quot;basic-init&quot;&gt;
        &lt;patternset id=&quot;module.files&quot;&gt;
            &lt;include name=&quot;${module.jar}&quot;/&gt;
            &lt;include name=&quot;${javahelp.jar}&quot; if=&quot;has.javahelp&quot;/&gt;
            &lt;include name=&quot;${nb.system.dir}/Modules/${code.name.base.dashes}.xml&quot;/&gt;

            &lt;!-- Начало перечня дополнений к FeedReader --&gt;
            &lt;include name=&quot;${nb.lib.dir}/locale/core_rss.jar&quot;/&gt;
            &lt;include name=&quot;${nb.modules.dir}/locale/org-netbeans-core-windows_rss.jar&quot;/&gt;
        &lt;/patternset&gt;
    &lt;/target&gt;

    &lt;!-- 
    netbeans-extra представляет собой привязку для копирования файлов. 
    --&gt;
    &lt;target name=&quot;netbeans-extra&quot; depends=&quot;init&quot;&gt;
        &lt;mkdir dir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.lib.dir}/locale&quot;/&gt;
        &lt;mkdir dir=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/locale&quot;/&gt;

        &lt;jar destfile=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.lib.dir}/locale/core_rss.jar&quot; 
             basedir=&quot;core&quot;/&gt;
        &lt;jar destfile=&quot;${netbeans.dest.dir}/${cluster.dir}/${nb.modules.dir}/locale/org-netbeans-core-windows_rss.jar&quot; 
             basedir=&quot;core-windows&quot;/&gt;
    &lt;/target&gt;</PRE><P>
В этом случае добавляются два файла jar: <FONT FACE="Courier, monospace">core_rss.jar</FONT> и <FONT FACE="Courier, monospace">org-netbeans-core-windows_rss.jar</FONT>. Эти файлы jars соответствуют файлам <FONT FACE="Courier, monospace">core.jar</FONT> и <FONT FACE="Courier, monospace">org-netbeans-core-windows.jar</FONT>. На самом деле любой файл jar в стандартной установке NetBeans можно подвергнуть &quot;брэндингу&quot; путем размещения другого файла jar относительно оригинала:</P>
<PRE>/path/to/original.jar
/path/to/locale/original_brandname.jar</PRE><P>
Напомним, что скрипту интерпретатора команд в модуле JDIC передается параметр &quot;&ndash;branding rss&quot;. Таким образом &quot;имя брэнда&quot; в данном случае &mdash; &quot;rss&quot;.</P>
<P>Брэндинг возможен практически для любого файла ресурсов. Для значков, пакетов, файлов слоя и т.д. В файле <FONT FACE="Courier, monospace">core_rss.jar</FONT> брэндинг применен только к экрану заставки и к пакету ресурсов, содержащему значения, определяющие отображение экрана заставки. В файле <FONT FACE="Courier, monospace">org-netbeans-core-windows_rss.jar</FONT> брэндирован только один пакет для переопределения текста главного заголовка.</P>
<h2>Попробуйте снова!</h2>
<P>Теперь должен открыться экран, подобный показанному на снимке экрана в начале статьи. Итак, в статье продемонстрировано создание настоящего приложения на платформе NetBeans.</P>
<h2>Вопросы?</h2>
<P>Направляйте вопросы в список рассылки <A HREF="mailto:dev@openide.netbeans.org">dev@openide.netbeans.org</A>. Сведения о списках рассылки NetBeans приведены по адресу <A HREF="https://netbeans.org/community/lists/top.html">https://netbeans.org/community/lists/top.html</A>.</P>
</BODY>
</HTML>

