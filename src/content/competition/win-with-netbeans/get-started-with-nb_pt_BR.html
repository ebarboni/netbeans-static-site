<html>
	<head>
	  <META NAME="AUDIENCE" CONTENT="NBUSER">
	  <META NAME="TYPE" CONTENT="ARTICLE">
	  <META NAME="TOPIC" CONTENT="BASIC">
	  <META NAME="description" CONTENT="Getting Started with NetBeans and Java">
	  <link rel="stylesheet" type="text/css" href="../../netbeans.css">
		<title>Primeiros passos com o NetBeans e Java</title>
		</head>
	<body>

		<h1>Primeiros passos com o NetBeans e Java</h1>
<div class="articledate" style="margin-left:0px;">Contribui&ccedil;&atilde;o de Ben Suter como parte da competi&ccedil;&atilde;o <a href="../../competition/win-with-netbeans.html">Win With NetBeans</a></div></p>
		<p>Esse artigo assume que voc&ecirc; tenha instalado com &ecirc;xito o NetBeans 4.0 e um Java SDK (tamb&eacute;m conhecido como JDK).
		<!-- If you have not yet done so, please refer to <a href="https://netbeans.org/kb/articles/nb-install-sequence.html">this brief introduction</a>, which shows the step-by-step installation sequence for NetBeans.</p> -->

		<p>Primeiro vamos explorar nosso novo IDE e um dos aplicativos de amostra incorporado. Na primeira se&ccedil;&atilde;o faremos uso intenso de capturas de tela e permitiremos que voc&ecirc; mergulhe - imediatamente ap&oacute;s completar a instala&ccedil;&atilde;o do NetBeans. A seguir, iremos aprender como usar o NetBeans para modificar, compilar e executar um aplicativo Java. Ao progredirmos, h&aacute;ver&aacute; menos capturas de tela e mais c&oacute;digo-fonte. Nosso passo ir&aacute; acelarar ao aprendermos como usar algumas das fun&ccedil;&otilde;es mais ava&ccedil;adas de produtividade e aprimoramento do NetBeans, ao adicionar aprimoramentos interessantes no aplicativo de amostra &quot;Anagram Game&quot;. No final deste artigo, voc&ecirc; saber&aacute; como usar o NetBeans para escrever c&oacute;digo Java que abra e analise documentos XML, solicita a entrada pelo usu&aacute;rio em caixas de di&aacute;logo simples, e muito mais. Mais importante, voc&ecirc; estar&aacute; bem apto para criar e estender aplicativos Java. Vamos mergulhar!</p>


		<ol>
			<li><a href="#1">Primeiros passos: Explorando o NetBeans e Iniciando um Projeto</a></li>
			<li><a href="#2">Modificando o c&oacute;digo-fonte</a></li>
			<li><a href="#3">Porque t&atilde;o previs&iacute;vel?</a></li>
			<li><a href="#4">Uma dose saud&aacute;vel do java.util.Random</a></li>
			<li><a href="#5">Carregando listas de palavras a partir de arquivos</a></li>
			<li><a href="#files">Listagem dos arquivos relacionados</a></li>
		</ol>

		<h2><a name="1">Primeiros passos: Explorando o NetBeans e Iniciando um Projeto</a></h2>

		<p>Quando inicie pela primeira vez o NetBeans no menu Iniciar, ele foi carregado em 15 segundos. Em alguns casos, isso pode levar mais tempo na primeira vez devido ao fato de que o NetBeans est&aacute; conhecendo seu sistema. </p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-initial-splash.png" />
		<p>Neste ponto voc&ecirc; deveria se sentir a vontade para explorar um pouco - e quando em d&uacute;vida, escolha &quot;Cancelar&quot;! Quando estiver pronto para continuar, siga em frente e clique no bot&atilde;o &quot;Projeto de amostra&quot; sob o gr&aacute;fico Bem-vindo.</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-1-choose.png" />
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-2.png" />
		<p>Por padr&atilde;o, a localiza&ccedil;&atilde;o do projeto ser&aacute; definda na sua pasta principal. Vamos adiante para criar uma pasta denominada &quot;code&quot; na unidade C:, e a seguir uma unidade denominada &quot;java&quot; na mesma. Esnt&atilde;o use o bot&atilde;o Procurar para escolher esta nova pasta como a localiza&ccedil;&atilde;o do projeto, como mostrado na pr&oacute;xima captura de tela.</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-3.png" />
		<p>Ap&oacute;s clicar em &quot;Concluir&quot; na caixa de di&aacute;lgo acima, aparece uma caixa de di&aacute;logo &quot;Varrendo classpaths do projeto&quot; que pode durar cerca de um minuto.</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-project-4-scanningclasspath.png" />
		<p>Agora a aba &quot;Projetos&quot; no &quot;painel&quot; esquerdo exibe um n&oacute; &uacute;nico denominado &quot;AnagramGame&quot;. A tela splash de boas vindas ainda est&aacute; vis&iacute;vel na &aacute;rea &quot;principal&quot;. A expans&atilde;o do n&oacute; &quot;AnagramGame&quot; na aba &quot;Projetos&quot;, e sequencialmente expandir seus n&oacute;s secund&aacute;rios, resulta na seguinte estrutura de &aacute;rvore:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-projectstructure.png" />
		<p>Acima Eu redimensionei a janela principal do NetBeans para apenas mostrar o &quot;painel&quot; esquerdo.</p>
		<p>Devemos observar que este aplicativo de amostra &eacute; composto de dois &quot;pacotes de c&oacute;digo-fonte (um uma biblioteca, e outro a interface do usu&aacute;rio) e um &quot;pacote de teste (para a biblioteca). Devemos tamb&eacute;m observar cada classe, al&eacute;m da Fields/Constructors/Methods, h&aacute; um n&oacute; &quot;Bean Patterns&quot; (embora este n&oacute; esteja vazio para cada classe atual acima). Neste artigo n&atilde;o iremos usar n&oacute;s &quot;Bean Pattern&quot;, mas voc&ecirc; deveria saber que eles ajudam a tornar seu c&oacute;digo mais modular, flex&iacute;vel e reutiliz&aacute;vel atrav&eacute;s do uso de <a href="http://java.sun.com/products/javabeans/index.jsp">componentes JavaBeans</a>.</p>
		<p>A seguir, clique duas vezes no n&oacute; &quot;About.java&quot; - voc&ecirc; ver&aacute; algo parecido com isso:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-about-designmode.png" />
		<p>Se desejar, poder&aacute; fechar a aba &quot;Bem-vindo&quot; na &aacute;rea/painel principal. Neste momento voc&ecirc; uma vez mais pode desejar explorar o NetBeans por si pr&oacute;prio: voc&ecirc; pode abrir arquivos de c&oacute;digo-fonte, visualizar &quot;formas&quot; visuais para algumas das classes de interface do usu&aacute;rio, ou examinar arquivos n&atilde;o de c&oacute;digo fonte ao alternar da aba &quot;Projetos&quot; para a aba &quot;Arquivos&quot; no painel esquerdo. Ali &eacute; poss&iacute;vel examinar diversos arquivos .properties e script de build Ant. No menu &quot;Ferramentas&quot;, a janela &quot;Op&ccedil;&otilde;es&quot; lhe dar&aacute; uma id&eacute;ia de qu&atilde;o flex&iacute;vel e personaliz&aacute;vel o IDE realmente &eacute;!</p>
		<p>Como uma boa medida e para assegurar que voc&ecirc; seja capaz de descansar e saber como reiniciar novamente, vamos adiante e fechar e a seguir reabrir o NetBeans. Caso o fa&ccedil;a, voc&ecirc; ver&aacute; que desta vez o IDE abre com uma &aacute;rea principal em branco, e a &aacute;rea &quot;Projetos&quot; ir&aacute; mostrar o projeto AnagramGame. Agora clique no bot&atilde;o &quot;Executar projeto principal (F6)&quot; na barra de ferramentas (&eacute; verde e amarelo; voc&ecirc; pode passar o mouse sobre ela para ver o t&iacute;tulo do &iacute;cone), e o NetBeans abre uma janela &quot;Sa&iacute;da&quot;, contendo o seguinte texto:</p>
<pre class='examplecode'>
init:
deps-jar:
Created dir: C:\code\java\AnagramGame\build\classes
Compiling 3 source files to C:\code\java\AnagramGame\build\classes
compile:
run:
</pre>
		<p>Al&eacute;m disso, aparece uma pequena janela, a interface do usu&aacute;rio para o AnagramGame.</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-game-1.png" />
		<p>Dei a primeira resposta certa em minha primeira tentativa! Acho que ajudou o fato de ter navegado atrav&eacute;s das pastas e arquivos do projeto anterirmente, j&aacute; que me lembro de ter visto uma longa lista de palavras (a lista de palavras n&atilde;o misturadas, presumo) e isso pode ter me ajudado. Vamos ter isso em mente para mais tarde...</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-game-2.png" />


		<h2><a name="2">Modificando o c&oacute;digo-fonte</a></h2>

		<p>Primeiro n&oacute;s alteramos o texto de uma das mensagens ao usu&aacute;rio no aplicativo de amostra. No painel &quot;Projetos&quot;, clique duas vezes no n&oacute; toy.anagram.ui.Anagram e o seu c&oacute;digo-fonte ser&aacute; aberto como uma nova aba na &aacute;rea da janela principal. O canto superior direito da aba tem um bot&atilde;o &quot;Projeto&quot; e &quot;C&oacute;digo-fonte&quot;. Escolha o bot&atilde;o &quot;C&oacute;digo-fonte&quot; caso j&aacute; n&atilde;o esteja selecioado - e voc&ecirc; vera agora o c&oacute;digo-fonte Java para a classe Anagram no editor. Clique com o bot&atilde;o direito do mouse na margem esquerda e assegura que &quot;Mostrar n&uacute;meros de linhas&quot; esteja selecionado. Siga para a linha n&ordm; 211 (CTRL-G &eacute; r&aacute;pido). Esta linha deveria ler:</p>
		<pre class='examplecode'>feedbackLabel.setText(&quot;Incorrect! Try again!&quot;);</pre>
		<p>N&oacute;s iremos (trib=vialmente) alterar o texto, compilar e executar o aplicativo, adivinhas errado uma palavra, e ver a mensagem modificada. Eu alterei a minha para ler:</p>
		<pre class='examplecode'>feedbackLabel.setText(&quot;Not quite ... please try again!&quot;);</pre>
		<p>Neste momento, observe que no t&iacute;tulo da aba do editor agora h&aacute; um pequeno aster&iacute;sco entre a palavra &quot;Anagramas&quot; e o &quot;X&quot; (comando Fechar). Este aster&iacute;sco indica que o arquivo foi modificado, mas ainda n&atilde;o foi salvo. Arquivo-&gt;Salvar (ou CTRL-S) ir&aacute; salvar nossas altera&ccedil;&otilde;es. Portanto, neste momento, nosso arquivo de c&oacute;digo-fonte foi modificado e salvo, mas o arquivo da classe compilada ainda reflete o c&oacute;digo antigo. Aqui &eacute; onde o NetBeans ir&aacute; tratar das duas etapas de uma s&oacute; vez por n&oacute;s: clique no &iacute;cone verde/amarelo &quot;Executar projeto principal&quot; ou pressione F6. O aplicativo ser&aacute; aberto como antes. No entanto, no console de sa&iacute;da, voc&ecirc; deveria ver o seguinte:</p>
<pre class='examplecode'>
init:
deps-jar:
Compiling 1 source file to C:\code\java\AnagramGame\build\classes
compile:
run:
</pre>
		<p>Como voc&ecirc; pode ver, antes de executar o aplicativo, o NetBeans (de fato nosso script Ant do build) verificou que aquele arquivo foi modificado e compilou o mesmo por n&oacute;s antes de executar a &quot;tarefa de execu&ccedil;&atilde;o&quot;. Siga adiante e insira uma adivinha&ccedil;&atilde;o, preferencialmente incorreta. Se tudo correr como o esperado, a mensagem de feedback deveria agora aparecer com o texto acima personalizado.</p>
		<p>Siga adiante e jogue algumas rodadas - Eu fiquei preso em &quot;iccmustsnaec&quot;. Para poder demonstrar os recursos essencials do NetBeans, irei trapacear e pesquisar a solu&ccedil;&atilde;o no c&oacute;digo-fonte. Isso pressup&otilde;em que as vers&otilde;es misturadas de cada palavra est&atilde;o listadas nos arquivos de c&oacute;digo-fonte do projeto, ao inv&eacute;s de ser gerada cada vez ao misturar aleatoriamente a palavra original. Em um minuto, n&oacute;s veremos que essa &eacute; de fato a natureza do aplicativo atual. Mais tarde faremos algo sobre isso...</p>
		<p>Na aba &quot;projetos&quot;, clique com o bot&atilde;o direito do mouse no n&oacute; &quot;Pacotes de c&oacute;digo-fonte&quot; e selecione &quot;Localizar...&quot; no menu de contexto. Voc&ecirc; ser&aacute; apresentado com a seguinte tela, denominada &quot;Localizar&quot;:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-find-1.png" />
		<p>Na captura de tela, voc&ecirc; pode ver que Eu j&aacute; inseri o texto &quot;iccrmutsnaec&quot; como meu termo de pesquisa. N&oacute;s iremos deixar as outras configura&ccedil;&otilde;es como est&atilde;o e iremos clicar em &quot;Pesquisar&quot; para iniciar o processo. Aparecer&aacute; uma nova aba junto ao console de sa&iacute;da, indicando os resultados da pesquisa. Como voc&ecirc; pode ver, foi encontrada uma coincid&ecirc;ncia, no arquivo &quot;WordLibrary.java&quot; na linha n&ordm; 53:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-find-2.png" />
		<p>Clique duas vezes na coincid&ecirc;ncia (o n&oacute; denominado &quot;iccrmutsnaec&quot;, [posi&ccedil;&atilde;o 63:10] acima). Isso ir&aacute; abrir o arquivo de c&oacute;digo-fonte correspondnete no editor. Assegure que a linha apropriada esteja vis&iacute;vel e realce a frase coincidente. O que voc&ecirc; deveria ver &eacute; que o termo &quot;iccrmutsnaec&quot; &eacute; a sexta entrada em uma matriz de sequ&ecirc;ncia de caracteres; essa matriz &eacute; denominada &quot;SCRAMBLED_WORD_LIST&quot;. Observe agora que imediatamente acima desta matriz h&aacute; outra matriz de sequ&ecirc;ncia de caracteres, mas nessa as entradas paracem ser palavras reais no idioma Ingl&ecirc;s. Vamos ver porque aquela matriz &eacute; denominada: &quot;WORD_LIST&quot;. Neste ponto, estou seguro, que n&oacute;s verificamos que a solu&ccedil;&atilde;o para a palavra &quot;iccrmutsnaec&quot; misturada pode ser encontrada na sexta entrada da matriz &quot;WORD_LIST&quot;. &Eacute; claro que &eacute; poss&iacute;vel que o autor original escolheu um mapeamento menos &oacute;bvio entre o texto claro e suas vers&otilde;es misturadas, mas afortunadamente n&atilde;o o fez! Portanto, examinando a linha n&ordm; 16 n&oacute;s vemos a palavra &quot;circumstance&quot; Ao digitar esta palavra no aplicativo (caso entrementes voc&ecirc; o tenha fechado, poder&aacute; jogar novamente at&eacute; alcan&ccedil;ar o ponto apropriado), voc&ecirc; ver&aacute; a seguinte tela:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-game-3.png" />


		<h2><a name="3">Porque t&atilde;o previs&iacute;vel?</a></h2>

		<p>Agora j&aacute; sabemos como abrir um arquivo para edi&ccedil;&atilde;o, como modificar o c&oacute;digo-fonte, como compilar e executar o aplicativo, como pesquisar o c&oacute;digo-fonte e como trapacear. Vamos juntar alguns desses conhecimentos para tornar o AanagramGame mais interessante. N&oacute;s iremos implementar a gera&ccedil;&atilde;o din&acirc;mica de palavras misturadas, eliminando a necessidade de manter uma lista de palavras misturadas no c&oacute;digo-fonte. Como resultado, iremos eliminar uma forma de trapacear. Na segunda etapa n&oacute;s iremos assegurar que as vers&otilde;es misturadas sejam geradas aletoriamente, portanto, a forma de jogar se torna mais interessante.</p>
		<p>Ainda no c&oacute;digo-fonte WordLibrary, voc&ecirc; ver&aacute; um m&eacute;todo denominado &quot;getScrambledWord&quot;. Examinando mais de perto este m&eacute;todo, n&oacute;s veremos que sua implementa&ccedil;&atilde;o &eacute; extramamente simples.</p>
		<pre class='examplecode'>return SCRAMBLED_WORD_LIST[idx];</pre>
		<p>Esse &eacute; de fato um bom lugar para fazerr nossas modifica&ccedil;&otilde;es. Vamos come&ccedil;ar por alterar esta linha (n&ordm; 126) para o seguinte:</p>
		<pre class='examplecode'>return generateScrambledWord(idx);</pre>

		<p>O NetBeans agora marca esta linha de c&oacute;digo com uma linha ondulada sublinhada vermelha e com um &iacute;cone X vermelho na margem, indicando que ali encontrou um problema de sintaxe em nosso c&oacute;digo-fonte. Se colocarmos o cursor sobre qualquer parte do c&oacute;digo-fonte sublinhado, aparecer&aacute; uma pequena mensagem, indicandando que ele n&atilde;o reconhece a assinatura do m&eacute;todo generateScrambledWord(int). &Eacute; claro, n&oacute;s ainda n&atilde;o criamos este m&eacute;todo, portanto, vamos faz&ecirc;-lo agora. Basta adicion&aacute;-lo no fim da classe, iniciando na linha n&ordm; 147:</p>
<pre class='examplecode'>
    /**
     * For a specified index, finds the corresponding word in the
     * dictionary and generates a scrambled version of this word.
     * @param idx index of the word to be scrambled
     * @return a scrambled version of the relevant word
     */
    protected static String generateScrambledWord(int idx)
    {
	int j = 0;
	String word;
	String scrambled = &quot;&quot;;
	java.util.Random r;

	r = new java.util.Random();
	word = getWord(idx);

	for (j = 0; j &lt;word.length(); j++)
	{
	    if ( r.nextBoolean() )
		scrambled = scrambled + word.charAt(j);
	    else
		scrambled = word.charAt(j) + scrambled;
	}

	return scrambled;
    }
</pre>
		<p>O prop&oacute;sito de nossa fun&ccedil;&atilde;o generateScrambledWord(int) &eacute; o de retornar uma vers&atilde;o misturada da entrada do dicion&aacute;rio especificada pelo argumento inteiro, o &iacute;ndice. Estou certo que n&oacute;s poder&iacute;amos pensar sobre diferentes maneiras de misturara (reordenar) as letras de uma palavra e, voc&ecirc; tem a liberdadede de implementar o corpo deste m&eacute;todo da forma que achar melhor. Isso poderia ser simples como reverter a ordem das letras, mas ent&atilde;o o jogo poderia ser muito f&aacute;cil (mesmo assim, tente faz&ecirc;--lo). Alternativamente, poder&iacute;amos trocar a posi&ccedil;&atilde;o de quaisquer letras adjacentes, um par de cada vez, at&eacute; alcan&ccedil;armos o fim da palavra. Deixe sua imagina&ccedil;&atilde;o fluir e encontre um algor&iacute;tmo que seja divertido de implementar e que forne&ccedil;a um jogo divertido. Permita-me explicar um pouco a pensamento por tr&aacute;s da implementa&ccedil;&atilde;o que forneci neste exemplo. Eu escolhi usar o utilit&aacute;rio de gera&ccedil;&atilde;o de n&uacute;meros aleat&oacute;rios incorporado no Java, de tal forma que o resultado da mistura de uma determinada palavra ainda pare&ccedil;a diferente cada vez que for gerada. N&oacute;s contru&iacute;mos a palavra misturada, uma letra de cada vez, e para cada nova letra, deixamos que um n&uacute;mero aleat&oacute;rio determine se a nova letra deve ser adicionada no in&iacute;cio ou no fim da palavra fragmentada. Desta forma, n&oacute;s constru&iacute;mos um nova palavra, consistindo em todas as letras da palavra original, mas em uma sequ&ecirc;ncia um pouco aleat&oacute;ria. Neste ponto, siga adiante e execute o aplicativo. Desta vez n&atilde;o fui capaz de adivinhar corretamente muitas das palavras, mas devido ao grau de aleatoridade do sequenciamento, algumas vezes posso ver uma palavra misturada que se parece de perto com a forma n&atilde;o misturada. Voc&ecirc; pode tentar modificar o algor&iacute;tmo acima para reordenar pares de caracteres ao inv&eacute;s de caracteres individuais e, as palavras resultantes podem ser uma pouco mais f&aacute;ceis de serem indentificadas. Caso voc&ecirc; implemente um algor&iacute;tmo que cria um jogo especialmente desafiante, compartilhe o mesmo com os leitores deste artigo.</p>
		<p>Neste momento, n&oacute;s n&atilde;o estamos mais fazendo uso do dicion&aacute;rio de palavras misturadas (a matriz SCRAMBLED_WORD_LIST), portanto, vamos seguir adiante e remov&ecirc;-lo do c&oacute;digo-fonte WordLibary.java (linhas 57 a 104).</p>


		<h2><a name="4">Uma dose saud&aacute;vel do java.util.Random</a></h2>

		<p>Caso voc&ecirc; jogue a nova vers&atilde;o do jogo, poder&aacute; (como Eu fiz) ficar frustado com sua inabilidade de identificar as palavras subjacentes. O que fazer? Bom, n&oacute;s sabemos que as palavras originais s&atilde;o armazenadas em um dicion&aacute;rio simples e, tamb&eacute;m sabemos que o jogo passa por este dicion&aacute;rio uma palavra de cada vez, do in&iacute;cio ao fim. Portanto, com o c&oacute;digo atual, como temos acesso ao c&oacute;digo-fonte, ainda podemos trapacear ao manter o acompanhamento de quantas palavras j&aacute; tentamos e ao examinar a entrada correspondente do dicion&aacute;rio. Quando executo o jogo, a primeira palavra misturada que vejo &eacute; noiatabsrct e n&atilde;o a reconhe&ccedil;o imediatamente. Mas se formos para a linha n&ordm; 11 em WordLibrary.java, vemos que a entrada do dicion&aacute;rio &eacute; abstraction. Nosso pr&oacute;ximo objetivo &eacute; definir a aleatoridade da ordem com a qual as palavras s&atilde;o tiradas do dicion&aacute;rio, e vamos ent&atilde;o fazer isso de novo usando a classe Ramdom do pacote java.util. J&aacute; que estamos usando esta classe duas vezes, vamos examinar um pouco sua documenta&ccedil;&atilde;o API, para termos um entendimento b&aacute;sico do ela faz por n&oacute;s:</p>
		<p>Uma inst&acirc;ncia dessa classe &eacute; usada para gerar um fluxo de n&uacute;meros pseudo-aleat&oacute;rios. A classe usa uma semente de 48 bits, que &eacute; modificada usando uma f&oacute;rmula &quot;Linear Congruential&quot;. (Consulte Donald Knuth, The Art of Computer Programming, Volume 2, Se&ccedil;&atilde;o 3.2.1.) Se duas inst&acirc;ncias de Random forem criadas com a mesma semente, e a mesma chamada do m&eacute;todo de sequ&ecirc;ncia &eacute; feita para cada, elas ir&atilde;o gerar e retornar sequ&ecirc;ncias id&ecirc;nticas de n&uacute;meros.</p>
		<p>At&eacute; agora, n&oacute;s usamos o construtor de argumento zero para o java.utilRandom, por conveni&ecirc;ncia. Como os coment&aacute;rios API acima indicam, n&oacute;s dever&iacute;amos tomar cuidado em inicializar cada inst&acirc;ncia de Random com uma semente &uacute;nica, caso contr&aacute;rio o uso repetitivo do aplicativo pode n&atilde;o ter uma natureza aleat&oacute;riia suficiente. Examinando a <a href="http://java.sun.com/j2se/1.4.2/">documenta&ccedil;&atilde;o</a> para o construtor de argumento zero, podemos ver que ela de fato usa a hora atual (em milesegundos) como uma semente, portanto, nosso c&oacute;digo atual est&aacute; OK e podemos ent&atilde;o seguir em frente para coisas mais importantes.</p>
		<p>Quais s&atilde;o as modifica&ccedil;&otilde;es que precisamos fazer para tornar aleat&oacute;ria a ordem das palavras escolhidas no dicion&aacute;rio? Em nossa classe WordLibrary, vemos que h&aacute; dois m&eacute;todos que percem relevantes: getWord(int idx) e getScrambledWord(int idx) aceitam como seu argumento um &iacute;ndice para o dicion&aacute;rio. Vamos primeiro colocar o cursor no m&eacute;todo getWord, e a seguir, clicar com o bot&atilde;o direito do mouse e escolhar a op&ccedil;&atilde;o Localizar usos. N&oacute;s vemos tr&ecirc;s chamadas para este m&eacute;todo (uma em WordLibraryTest, duas em WordLibrary itself). Cada uma destas &eacute; usada internamente pelo componente WordLibrary (incluindo seu teste de harness) e nada precisa aqui ser modificado. A seguir, colocaremos nosso cursor no m&eacute;todo getScrambledWord, e a seguir pressionar Alt-F7. Uma vez mais vemos tr&ecirc;s usos do m&eacute;todo, mas agora dois desles est&atilde;o na classe Anagrams e vamos focar aten&ccedil;&atilde;o nos mesmos. Em ambos os casos (linhas 28 e 195) o valor do argumento passado para getScrambledWord &eacute; uma vari&aacute;vel denominada wordIdx. Essa pr&oacute;pria vari&aacute;vel est&aacute; declarada na linha 22 e inicializada como zero. Vamos pesquisar os usos da vari&aacute;vel wordIdx: h&aacute; tr&ecirc;s.</p>
		<ol>
			<li>Na linha 28 n&oacute;s vemos que o construtor de nosso jogo preenche inicialmente o controle de palavra misturada usando a primeira palavra no dicion&aacute;rio.</li>
			<li>No m&eacute;todo nextTrialActionPerformed a vari&aacute;vel wordIdx &eacute; incrementada (observe que ela repete em zero quando todas as palavras tiveram sido tentadas) e &eacute; ent&atilde;o usada para preencher o controle de palavra misturada com um novo valor.</li>
			<li>No m&eacute;todo guessedWordActionPerformed as adivinha&ccedil;&otilde;es do usu&aacute;rio s&atilde;o avaliadas, usando o valor atual da vari&aacute;vel wordIdx para indicar a palavra relevante.</li>
		</ol>
		<p>Agora vemos que a vari&aacute;vel wordIdx variable determina qual palavra &eacute; escolhida ap&oacute;s cada adivinha&ccedil;&atilde;o, e esta vari&aacute;vel somente &eacute; modificada em um lugar, a linha n&ordm; 192 do Anagrams.java:</p>
		<pre class='examplecode'>wordIdx = (wordIdx + 1) % WordLibrary.getSize();</pre>
		<p>Para tornar aleat&oacute;ria a ordem de escolha das palavras no dicion&aacute;rio, precisamos modificar esta linha para que a wordIdx pegue os valores aleat&oacute;rios que estejam dentro dos limites inferior e superior do dicion&aacute;rio. O m&eacute;todo java.util.Random.nextInt(int n) faz exatamente isso, portanto, vamos seguir adiante e substituir a linha n&ordm; 192 pela seguinte linha de c&oacute;digo:</p>
		<pre class='examplecode'>wordIdx = new java.util.Random().nextInt(WordLibrary.getSize());</pre>
		<p>Para verificar se isso alcan&ccedil;a o efeito desejado, precisamos &eacute; claro jogar uma vez mais! A primeira palavra est&aacute; se tornando f&aacute;cil agora, j&aacute; que sempre parece seu uma forma misturada da palavra abstraction. De fato, o construtor Anagram sempre come&ccedil;a o jogo ao escolher a primeira palavra no dicion&aacute;rio, j&aacute; que a vari&aacute;vel wordIdx &eacute; incialiizada de forma est&aacute;tica com um valor de zero. Mas ap&oacute;s passar da primeira palavra no jogo, todas as escolhas subsequentes parecem ser adequadamente imprevis&iacute;veis. Portanto, esperamos ter tornado o jogo um pouco mais divertido, e n&oacute;s temos apenas uma forma mais (assumindo que possa ler o c&oacute;digo-fonte) de trapacear. Caso goste, voc&ecirc; pode seguir adiante e assegurar que a primeira palavra do jogo seja tamb&eacute;m escolhida aleatoriamente do dicion&aacute;rio. Para fazer isso, assegure que o valor inicial da vari&aacute;vel wordIdx seja calculado da mesma forma que os valores subsequentes - com isso, a linha n&ordm; 22 do Anagrams.jva, se torna:</p>
		<pre class='examplecode'>private int wordIdx = wordIdx = new java.util.Random().nextInt(WordLibrary.getSize());</pre>


		<h2><a name="5">Carregando listas de palavras a partir de arquivos</a></h2>

		<p>Se voc&ecirc; &eacute; como Eu, poder&aacute; adivinhar que elxical &eacute; a forma misturada de lexical, mas quando confrontado com lasiugsidintinhbe iria estar clicando depressa em Nova palavra. O que torna indistinguishable mais dif&iacute;cil em m&eacute;dia do que lexical? Quanto menos letras houve na palavra original, mais provavelmente a forma misturada n&atilde;o ser&aacute; muito diferente, em fun&ccedil;&atilde;o de nosso algor&iacute;tmo atual para misturar as palavras. Geralmente acho ser mais f&aacute;cil desmisturar a palavar qu&atilde;o mais curta for, independente de como ela foi misturada. Para um iniciante, um conjunto de palavras mais curtas seria divertido, mas para um jogador mais experiente, um conjunto de palavras longas seria apropriado. Mas &eacute; claro que h&aacute; outras caracter&iacute;stcas al&eacute;m do comprimento da palavra, tal como se a palavra &eacute; raramente usada, ou se faz parte de um discurso, idioma ou t&oacute;pico. Podemos usar estas observa&ccedil;&otilde;es para tornar o jogo mais &uacute;til e, podemos aprender algo novo sobre o NetBeans e Java, j&aacute; que estamos aqui?</p>
		<p>Nesta se&ccedil;&atilde;o, n&oacute; iremos externalizar o dicion&aacute;rio, o que significa que ser&aacute; poss&iacute;vel jogar o jogo com um n&uacute;mero diferente de listas de palavras e que o usu&aacute;rio poder&aacute; suprir sua pr&oacute;pria lista personalizada de palavras. H&aacute; v&aacute;rias maneiras de fazer isso. N&oacute;s iremos implementar esta funcionalidade ao ler um arquivo contendo uma lista de palavras, estruturada e formatada como XML. No final desta se&ccedil;&atilde;o, voc&ecirc; saber&aacute; como abrir e ler arquivos do sistema de arquivos local ou da Web e analisar com efici&ecirc;ncia um arquivo XML simples.</p>

		<p>N&oacute;s desejamos adicionar um novo item de menu para carregar uma lista externa de palavras. Para fazer isso, n&oacute;s alternamos para o modo de projeto. N&oacute;s iremos de algo como isso:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-loadWordList.png" />
		<p>Para isso:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-designMode.png" />
		<p>No modo de projeto, n&oacute;s tamb&eacute;m vemos uma painel na direita denominado Inspetor. Inicialmente ele se parece como:</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-form-inspector-initial.png" />
		<p>O painel Inspetor nos mostra uma estrutura hierarquica dos componentes Wing que comp&otilde;em nossa interface gr&aacute;fica do usu&aacute;rio. Se expandirmos o n&oacute; [JFrame]&quot;, veremos que o primeiro componente &eacute; denominado como mainMenu [JMenuBar]. Este por sua vez cont&eacute;m um item fileMenu [JMenu], que por sua vez cont&eacute;m dois n&oacute;s adicionais: aboutMenuItem [JMenuItem] e exitMenuItem [JMenuItem]. O padr&atilde;o aqui visto &eacute; que cada n&oacute; &eacute; denominado com o nome da vari&aacute;vel correspondente. O tipo de componente est&aacute; entre colchetes. O quadro pincipal de fato &eacute; a pr&oacute;pria classe Anagrams (ela herda de JFrame) e, portanto, o Inspetor n&atilde;o mostra um nome de inst&acirc;ncia para aquele primeiro componente. Nosso objetivo &eacute; o de adicionar um comando de menu para carregar uma lista externa de palavras, portanto, vamos usar o Inspetor para adicionar um novo item entre as entradas Sobre e Sair do menu Arquivo.</p>
		<img src="../../images_www/articles/win-with-netbeans/screenshot-Anagrams-form-inspector-addingMenuItem.png" />
		<p>Clique com o bot&atilde;o direito do mouse no n&oacute; fileMenuItem, escolha Adicionar e a seguir JMenuItem. Um novo item de menu &eacute; adicionado na terceira posi&ccedil;&atilde;o ap&oacute;s o item Sair. Inicialmente o NetBeans fornece um nome &agrave; este item auto-gerado, mas n&oacute;s iremos alterar isso para openNewListMenuItem ao clicar com o bot&atilde;o direito do mouse no novo item e escolher Renomear. Finalmente, clicamos com o bot&atilde;o direito do mouse novamente no novo item e escolhemos Mover acima, o que vai resultar na ordem desejada.</p>
		<p>Agora selecionamos exitMenuItem e clicamos no bot&atilde;o Proprieadeas no painel Propriedades imediatamente abaixo do Inspetor. Entre outras coisas, n&oacute;s vemos tr&ecirc;s propriedades interessantes: mnemonic, text, toolTipText. Para esse item espec&iacute;fico de menu, os valores para esses s&atilde;o, respectivamente, S, Sair e Sair equipe, Sair!. Vamos selecionar nosso novo item de menu e definir suas propriedades correspondentes como A, Abrir lista de palavras, Escolher novo arquivo de lista de palavras, substituindo a lista atual respectivamente.</p>
		<p>A seguir, desejamos adicionar c&oacute;digo que ser&aacute; executado sempre que este item de menu for selecionado pelo usu&aacute;rio: O NetBeans nos ajuda aqui de novo: no Inspetor, clique com o bot&atilde;o direito do mouse no n&oacute; openNewListMenuItem, escolha Eventos, a seguir, A&ccedil;&otilde;es, e a seguir actionPerformed nos menus suspensos. O NetBeans ir&aacute; criar um m&eacute;todo &quot;event-handler&quot; e retorn&aacute;-lo para a vista de C&oacute;digo-fonte, para que estejamos prontos para redigir a implementa&ccedil;&atilde;o necess&aacute;ria. O novo m&eacute;todo recebe automaticamenteo nome openNewListMenuItemActionPerformed, mas &eacute; seguro renome&aacute;-lo usando os comandos Refactor, caso assim o deseje. Um coment&aacute;rio para os que tenham experi&ecirc;ncia anterior com as ferramentas de projeto de IGU Swing: &eacute; bom visualizar q&atilde;o limpo e bem estruturado, nomeado e formatado est&aacute; o c&oacute;digo auto-gerado. Por exemplo, o c&oacute;digo para nossos tr&ecirc;s itens no menu Arquivo mant&eacute;m a mesma ordem que os pr&oacute;prios menus. Mas voltando para nossa tarefa: quando o usu&aacute;rio seleciona o item de menu Abrir a lista de palavras, n&oacute;s faremos que escolha um arquivo sem seu sistema de arquivos local, e a seguir tente abrir, analisar e usar esta nova lista de palavras. Se o arquivo estiver indispon&iacute;vel ou n&atilde;o cont&eacute;m uma lista v&aacute;lida de palavras, o jogo ir&aacute; continuar a usar a lista atual de palavras. Aqui est&aacute; o que o NetBeans nos forneceu para iniciar:</p>
<pre class='examplecode'>
private void openNewListMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
// TODO add your handling code here:
}
</pre>
		<p>Nosso Carregador ir&aacute; pegar um URL como seu argumento principal, portanto, precisamos gerar um URL apropriado com base no arquivo escolhido pelo usu&aacute;rio. Primeiro n&oacute;s criamos uma inst&acirc;ncia de JFileChooser e a usamos para exibir a caixa de di&aacute;logo Abrir arquivo. Se o usu&aacute;rio seleciona um arquivo, n&oacute;s geramos um URL para o mesmo ao pr&eacute;-anexar o arquivo:/// protocolo ao nome do caminho absoluto.</p>
<pre class='examplecode'>
   private void openNewListMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
	/* The &quot;initialDirectory&quot; variable determines what directory is first displayed
	 * when choosing a new word list. An empty or a null string will start the chooser
	 * in the user's default directory, which for Windows is typically &quot;My Documents&quot;,
	 * and for *nix is typically the user's home directory.
	 */
	String initialDirectory = &quot;&quot;;
	String fileURL;
	JFileChooser chooser;
	int returnVal;

	chooser = new JFileChooser(initialDirectory);
	returnVal = chooser.showOpenDialog((Component) evt.getSource());

	if ( returnVal == chooser.APPROVE_OPTION )
	{
	    /* To create a URL for a file on the local file-system, we simply
	     * pre-pend the &quot;file&quot; protocol to the absolute path of the file.
	     */
	    fileURL = &quot;file:///&quot; + chooser.getSelectedFile().getAbsolutePath();
	    this.loadWordList(fileURL);
	}
    }
</pre>
		<p>O m&eacute;todo acima demonstra como voc&ecirc; pode apresentar uma caixa de di&aacute;logo para escolher o arquivo. Isso ent&atilde;o chama o m&eacute;todo ainda desconhecido loadWordList. Esse m&eacute;todo deveria tomar como argumento o endere&ccedil;o de um arquivo de lista de palavras, e assumindo que o arquivo esteja OK, substituir a lista atual de palavras. Aqui est&aacute; como se parece o m&eacute;todo:</p>
<pre class='examplecode'>
    /**
     * Attempts to open and parse an XML file containing a
     * word list. If successful, this list of words will be
     * used in place of the current list.
     * The URL can for example point to a document on the local file-system,
     * such as &quot;file:///C:/testlist.xml&quot;, or to a document on the World Wide Web,
     * such as &quot;http://www.stanford.edu/~bsuter/simplewordlist.xml&quot;.
     *
     * @param url Address of an XML document containing a word list.
     */
    protected void loadWordList(String url)
    {
	/* Create an instance of the loader */
	com.toy.anagrams.lib.WordListFileLoader wlfl = new com.toy.anagrams.lib.WordListFileLoader();

	/* Open and parse the file, replace the current word list with the newly loaded list. */
	WordLibrary.setWordList(wlfl.loadList(url));

	/* Since the new word list's number of entries may be different from the old,
	 * we make sure that the current value of wordIdx is valid for the new list.
	 */
	wordIdx = new java.util.Random().nextInt(WordLibrary.getSize());
    }
</pre>
		<p>Vemos que h&aacute; uma nova classe em jogo, denominada WordLisdtFileLoader. Al&eacute;m disso, a classe WordLibrary tem um novo m&eacute;todo denominado setWordList. Adicionei este m&eacute;todo na linha n&ordm; 125, &eacute; bem simples:</p>
<pre class='examplecode'>
    public static void setWordList(String[] wordList)
    {
	if ( wordList != null )
	    WORD_LIST = wordList;
    }
</pre>
		<p>Todo o c&oacute;digo-fonte para a classe WordListFileLoader est&aacute; <a href="https://netbeans.org/files/documents/4/307/WordListFileLoader.java">aqui</a> dispon&iacute;vel, mas vamos examinar as partes importantes, uma de cada vez. Esta nova classe tem um m&eacute;todo signficativo, assim como uma classe interna que herda de org.xml.sax.helpers.DefaultHandler. Uma inst&acirc;ncia do WordListFileLoader &eacute; para abrir, ler, analisar e avaliar o conte&uacute;do de um arquivo XML de um sistema de arquivos local ou de um documento XML acess&iacute;vel via HTTP. Vamos examinar a descri&ccedil;&atilde;o de alto n&iacute;vel sobre o que faz o m&eacute;todo WordListFileLoader.loadList:</p>
		<ul>
			<li>Obt&eacute;m um InputStream para o documento especificado</li>
			<li>Cria um analisador SAX (API simples para XML) para este documento</li>
			<li>Define um &quot;handler&quot; que ir&aacute; responder a todos os eventos relevantes vindo do analisador SAX</li>
		</ul>
		<p>H&aacute; diversas formas para analisar um documento XML no Java. A abordadgem DOM (Document Object Model) pervasiva, resulta em um modelo hierarquico na mem&oacute;ria para o conjunto de n&oacute;s de documentos XML. Em nosso caso, a estrutura de nosso conjunto de dados &eacute; simples (ula lista de palavras), e n&oacute;s imeditamente convertemos a lista analisada em uma matriz String[], portanto, manter um documento XML na mem&oacute;ria e de pouco valor. O SAX &eacute; uma abordagem com base no evento quer a classe &quot;handler&quot; ouve para eventos do analisador que ocorrem quando o analisador encontra um elemento XML, ou um atributo, ou o fim de um elemento. O &quot;handler&quot; pode decidir escolher processar ou desconsiderar tais eventos. Caso adequada para o prop&oacute;sito, a abordagem SAX tende a ser prefer&iacute;vel, j&aacute; que pode tratar com facilidade documentos muito grandes.</p>
<pre class='examplecode'>
   public String[] loadList(String url)
   {
	InputStream is;
	try {
		URL u = new URL(url);
		is = u.openConnection().getInputStream();
	} catch (IOException ioe) {
	    report(&quot;Unable to open or find the specified wordlist.&quot;);
	    is = null;
	}

	if (is == null)
	{
	    report(&quot;Unable to load the requested wordlist. An error occurred while opening the file.&quot;);
	    return null;
	}

	SAXParserFactory parserFactory = SAXParserFactory.newInstance();
	SAXParser parser;
	try {
	  parser = parserFactory.newSAXParser();
	} catch ( ParserConfigurationException pce ) {
	    report(&quot;Error setting up the XML Parser. The parser is not properly configured. Loading aborted.&quot;);
	    return null;
	} catch ( SAXException saxe ) {
	    report(&quot;Error setting up the XML Parser. Loading aborted.&quot;);
	    return null;
	}

	try {
	    WordListHandler handler = new WordListHandler();
	    parser.parse(is, handler);
	} catch ( Exception e ) {
	    report(&quot;Unable to load the list, probably while performing SAX parsing.&quot;);
	    return null;
	}

	return this.list;
    }
</pre>
		<p>Como acima descrito, o &quot;handler&quot; SAX precisa impmentar diveros &quot;handlres&quot; de eventos, em nosso caso extamente tr&ecirc;s: iniciando um elemento, o conte&uacute;do de um elemento e fechando um elemento. O c&oacute;digo resultante se parece com:</p>
<pre class='examplecode'>
   public class WordListHandler extends DefaultHandler
   {
	protected String nodeType;
	protected ArrayList al;

	public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException
	{
	    if ( qName == &quot;word&quot; )
	    {
		nodeType = &quot;word&quot;;
	    } else if ( qName == &quot;wordlist&quot; ) {
	       al = new ArrayList();
	    }
	}

	public void endElement(String uri, String localName, String qName) throws SAXException
	{
	     if ( qName == &quot;word&quot; )
	     {
		 nodeType = null;
	     } else if (qName == &quot;wordlist&quot; ) {
		 /* Cast the ArrayList to a an array of String objects. */
		 list = (String[]) this.al.toArray(new String[al.size()]);
	     }
	}

	public void characters(char[] chars, int start, int length) throws SAXException
	{
	    if ( this.nodeType == &quot;word&quot; )
	    {
		this.al.add(new String(chars, start, length).trim());
	    }
	}
    }
</pre>
		<p>Nossa estrutura do documento da lista de palavras cont&eacute;m apenas doi tipos de elementos XML: element: &lt;word&gt; e &lt;wordlist&gt;. Nesta listagem de c&oacute;digo, voc&ecirc; pode ver que o trabalho real de adicionar uma nova palavra &agrave; lista ocorre dentro do m&eacute;todo de caracter&iacute;stica. Os outros dois m&eacute;todos mant&eacute;m o registro que qual n&oacute; estamos no momento lendo, e executa a configura&ccedil;&atilde;o apropriada e a&ccedil;&otilde;es de limpeza, tal como inicializar a nova lista de palavras e atualizar o campo da lista de classe externa, respectivamente.</p>
		<p>Todo o c&oacute;digo Java WordListFileLoader est&aacute; <a href="https://netbeans.org/files/documents/4/307/WordListFileLoader.java">aqui</a> dispon&iacute;vel. Um documento de amostra de lista de palavras est&aacute; <a href="https://netbeans.org/files/documents/4/305/simplelist.xml">aqui</a> dispon&iacute;vel ou pode se parecer com:</p>
<pre class='examplecode'>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;
&lt;wordlist&gt;
    &lt;word&gt;welcome&lt;/word&gt;
    &lt;word&gt;jacuzzi&lt;/word&gt;
    &lt;word&gt;elefant&lt;/word&gt;
    &lt;word&gt;abracadabra&lt;/word&gt;
&lt;/wordlist&gt;
</pre>
		<p>Portanto, agora voc&ecirc; &eacute; capaz de criar suas pr&oacute;prias listas de palavras ao criar e editar arquivos XML em um processador de palavras ou semelhante. Tendo algum tempo, tenho certeza que voc&ecirc; ir&aacute; criar listas de palavras divertidas e tem&aacute;ticas. Voc&ecirc; n&atilde;o gostaria de compartilhar as mesmas com outras pessoas? Voc&ecirc; gostaria de usar listas de palavras criadas por outras pessoas, talvez para tornar a adivinha&ccedil;&atilde;o de palavras mais desafiante? A boa not&iacute;cia &eacute; que n&oacute;s j&aacute; quase implementamso isso. A m&aacute; not&iacute;cia &eacute; que desta vez n&atilde;o vou lhe guiar pelas etapas necess&aacute;rias. Primeiro crie um novo item de menu (talvez chamado de Download arquivo de listas) da mesma forma que criamos o comando Abrir arquivos de listas. Adicione um m&eacute;todo para a a&ccedil;&atilde;o actionPerformed correspondente (como antes) e use o seguinte c&oacute;digo para implementar o m&eacute;todo:</p>
<pre class='examplecode'>
    private void downloadNewListMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
	String listURL;
	String prompt = &quot;Enter the URL to an XML word list:&quot;;
	String initialValue = &quot;http://&quot;;

	listURL = (String) javax.swing.JOptionPane.showInputDialog(prompt, initialValue);

	/* Perform some simple validation before attempting to download the new word list */
	if (listURL != null &amp;&amp; listURL.length() &gt; 0 &amp;&amp; listURL != initialValue)
	{
	    this.loadWordList(listURL);
	}
     }
</pre>
		<p>Isso &eacute; tudo que cobriremos neste artigo, mas espero que voc&ecirc; tenha visto qu&atilde;o direto e eficiente &eacute; desenvolver c&oacute;digo de iinterface g&aacute;ficado usu&aacute;rio limpo e correto usando o projetista de formul&aacute;rio do NetBeans. &Eacute; claro que n&oacute;s somente abordamos um pouco do que &eacute; poss&iacute;vel, mas n&oacute;s aprimoramos o aplicativo AnagramGame de formas &uacute;teis e, agora voc&ecirc; tem uma plataforma simples que pode ser usada para testar novos conceitos e aprender mais sobre o NetBeans. Voc&ecirc; se divertir&aacute; caso implemente suas pr&oacute;prias id&eacute;ias, mas aqui est&atilde;o algumas para que possa iniciar:</p>
		<ol>
			<li>Cada palavra na lista poderia ter um atributo de t&iacute;tulo e o aplicativo poderia exibir o nome da lista atual de palavras no t&iacute;tulo da janela.</li>
			<li>Quando uma lista de palavras n&atilde;o for muito grande, a mesma palavra provalmente apareceria repetidamente dentro de um n&uacute;mero pequeno de advinha&ccedil;&otilde;es, tornando o jogo mais previs&iacute;vel e menos divertido. Para endere&ccedil;ar esta quest&atilde;o, voc&ecirc; poderia implementar um cache de palavras recentemente usadas. A seguir, para cada solicita&ccedil;&atilde;o de nova palavra, verifique se a nova palavra est&aacute; no cache. Caso esteja, solicite uma nova palavra at&eacute; receber uma que n&atilde;o esteja no cache. Isso iria assegurar que n&atilde;o haja muita repeti&ccedil;&atilde;o. Acho que o tamanho do cache pode ser bem pequeno para obter uma baixa repeti&ccedil;&atilde;o na perspectiva dos usu&aacute;rios, mas o tamanho do cache sempre tem de ser menor do que o n&uacute;mero de palavras na lista, caso contr&aacute;rio voc&ecirc; acabar&aacute; com um ciclo indefinido.</li>
			<li>Voc&ecirc; poderia criar um carregador de lista de palavras diferente que aceite qualquer documento de texto. Este carregador iria analisar o texto para verificar todos os tokens de sequ&ecirc;ncia de caracteres e criar uma nova lista de palavras contendo todas as palavras &uacute;nicas, talvez requerendo um n&uacute;mero m&iacute;nimo de caracteres por palavra. Aponte este carregador para um site da Web de not&iacute;cias estrangeiras para um jogo verdadeiramente desafiante!</li>
		</ol>


		<h2><a name="files">Listagem dos arquivos relacionados</a></h2>
			<table>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/306/anagrams.jar">anagrams.jar</a></td>
				<td>O aplicativo AnagramGame modificado, como um arquivo JAR execut&aacute;vel. Clique para jogar!</td>
			</tr>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/305/simplelist.xml">simplelist.xml</a></td>
				<td>Uma lista de palavras de exemplo, como um documento XML.</td>
			</tr>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/307/WordListFileLoader.java">WordListFileLoader.java &nbsp;</a></td>
				<td>Uma analisador com base no SAX para listas de palavras XML.</td>
			</tr>
			<tr>
				<td><a href="https://netbeans.org/files/documents/4/304/anagrams-src.zip">anagrams-src.zip</a></td>
				<td>C&oacute;digo-fonte Java completo para o aplicativo AnagramGame modificado.</td>
			</tr>
		</table>

		<p></p>
	</body>
</html>
